<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cryptocurrency Airdrop & Staking App</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.14.3/dist/ethers.umd.min.js"></script>
  <script src="https://unpkg.com/@walletconnect/modal@2.7.0/dist/index.min.js"></script>
  <script src="https://unpkg.com/@walletconnect/ethereum-provider@2.21.5/dist/index.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body { font-family: 'Inter', sans-serif; }
    .scrollable-status { max-height: 300px; overflow-y: auto; scrollbar-width: thin; scrollbar-color: #4b5563 #e5e7eb; }
    .scrollable-status::-webkit-scrollbar { width: 8px; }
    .scrollable-status::-webkit-scrollbar-track { background: #e5e7eb; }
    .scrollable-status::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
    .tooltip { position: relative; }
    .tooltip:hover::after {
      content: attr(data-tooltip); position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%);
      background: #1f2937; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; white-space: nowrap; z-index: 10;
    }
    @media (max-width: 640px) {
      button { width: 100%; margin-top: 0.5rem; }
      input, select { width: 100%; }
    }
  </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 min-h-screen flex items-center justify-center p-4 sm:p-6 transition-colors duration-300">
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useCallback, useRef } = React;
    const { createRoot } = ReactDOM;
    const { ethers } = window;

    const AirdropStakingApp = () => {
      const [provider, setProvider] = useState(null);
      const [signer, setSigner] = useState(null);
      const [account, setAccount] = useState(null);
      const [selectedNetwork, setSelectedNetwork] = useState(null);
      const [connectedNetwork, setConnectedNetwork] = useState(null);
      const [status, setStatus] = useState('Please connect your wallet to begin.\n');
      const [isLoading, setIsLoading] = useState(false);
      const [walletProvider, setWalletProvider] = useState('MetaMask');
      const [walletConnectModal, setWalletConnectModal] = useState(null);
      const [recipients, setRecipients] = useState('');
      const [amount, setAmount] = useState('');
      const [tokenContract, setTokenContract] = useState('');
      const [tokenType, setTokenType] = useState('native');
      const [batchSize, setBatchSize] = useState('10');
      const [isConnected, setIsConnected] = useState(false);
      const [nftContract, setNftContract] = useState('');
      const [tokenIdStart, setTokenIdStart] = useState('');
      const [tokenIdEnd, setTokenIdEnd] = useState('');
      const [fetchMethod, setFetchMethod] = useState('events');
      const fileInputRef = useRef(null);

      const networks = [
        { chainId: '0x1', name: 'Ethereum Mainnet', rpcUrls: ['https://eth.llamarpc.com'], nativeCurrency: 'ETH', blockExplorerUrls: ['https://etherscan.io'] },
        { chainId: '0x89', name: 'Polygon Mainnet', rpcUrls: ['https://polygon-rpc.com'], nativeCurrency: 'MATIC', blockExplorerUrls: ['https://polygonscan.com'] },
        { chainId: '0x19', name: 'Cronos Mainnet', rpcUrls: ['https://evm.cronos.org', 'https://cronos-rpc.publicnode.com'], nativeCurrency: 'CRO', blockExplorerUrls: ['https://cronoscan.com'] }
      ];

      const erc20Abi = [
        {
          "constant": true,
          "inputs": [],
          "name": "decimals",
          "outputs": [{ "name": "", "type": "uint8" }],
          "type": "function"
        },
        {
          "constant": false,
          "inputs": [
            { "name": "_to", "type": "address" },
            { "name": "_value", "type": "uint256" }
          ],
          "name": "transfer",
          "outputs": [{ "name": "", "type": "bool" }],
          "type": "function"
        }
      ];

      const erc721Abi = [
        {
          "constant": true,
          "inputs": [{ "name": "tokenId", "type": "uint256" }],
          "name": "ownerOf",
          "outputs": [{ "name": "", "type": "address" }],
          "type": "function"
        },
        {
          "anonymous": false,
          "inputs": [
            { "indexed": true, "name": "from", "type": "address" },
            { "indexed": true, "name": "to", "type": "address" },
            { "indexed": true, "name": "tokenId", "type": "uint256" }
          ],
          "name": "Transfer",
          "type": "event"
        }
      ];

      useEffect(() => {
        const initWalletConnect = async () => {
          const projectId = 'YOUR_WALLET_CONNECT_PROJECT_ID'; // Replace with your actual project ID
          try {
            const modal = new window.WalletConnectModal({
              projectId: projectId,
              themeMode: 'light',
              themeVariables: { '--wcm-z-index': '1000', '--wcm-accent-color': '#3b82f6' }
            });
            setWalletConnectModal(modal);
            setStatus(prev => `${prev}WalletConnect initialized.\n`);
          } catch (error) {
            setStatus(prev => `${prev}Error initializing WalletConnect: ${error.message}. Please use MetaMask or refresh.\n`);
          }
        };
        initWalletConnect();
        setSelectedNetwork(networks.find(n => n.name === 'Cronos Mainnet'));
      }, []);

      const connectWallet = useCallback(async () => {
        if (!ethers || !ethers.BrowserProvider || !ethers.isAddress) {
          setStatus(prev => `${prev}Error: Ethers.js library failed to load. Please refresh the page or try an alternative CDN: https://unpkg.com/ethers@6.14.3/dist/ethers.umd.min.js\n`);
          setIsLoading(false);
          return;
        }
        setIsLoading(true);
        setStatus(prev => `${prev}Connecting via ${walletProvider}...\n`);
        
        if (walletProvider === 'MetaMask') {
          if (!window.ethereum || !window.ethereum.isMetaMask) {
            setStatus(prev => `${prev}MetaMask not detected. Please install it.\n`);
            setIsLoading(false);
            return;
          }
          try {
            const browserProvider = new ethers.BrowserProvider(window.ethereum);
            const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
            if (accounts.length === 0) {
              setStatus(prev => `${prev}Please unlock MetaMask or grant permission.\n`);
            } else {
              const signer = await browserProvider.getSigner();
              setProvider(browserProvider);
              setSigner(signer);
              setAccount(accounts[0]);
              const network = await browserProvider.getNetwork();
              const chainId = `0x${network.chainId.toString(16)}`;
              const selectedNet = networks.find(n => n.chainId === chainId);
              if (selectedNet) {
                setConnectedNetwork(selectedNet);
                setSelectedNetwork(selectedNet);
                window.ethereum.on('chainChanged', (chainId) => {
                  const net = networks.find(n => n.chainId === chainId);
                  if (net) {
                    setConnectedNetwork(net);
                    setSelectedNetwork(net);
                  } else {
                    setStatus(prev => `${prev}Switched to unsupported network: ${chainId}\n`);
                  }
                });
                window.ethereum.on('accountsChanged', (accounts) => {
                  if (accounts.length > 0) {
                    setAccount(accounts[0]);
                  } else {
                    setIsConnected(false);
                    setAccount(null);
                    setConnectedNetwork(null);
                    setSigner(null);
                    setProvider(null);
                  }
                });
              } else {
                setStatus(prev => `${prev}Unsupported network: ${chainId}. Please switch to Cronos Mainnet.\n`);
              }
              setIsConnected(true);
              setStatus(prev => `${prev}Connected to MetaMask: ${accounts[0].slice(0, 6)}...${accounts[0].slice(-4)}\n`);
            }
          } catch (error) {
            setStatus(prev => `${prev}MetaMask connection failed: ${error.message}\n`);
          }
        } else if (walletProvider === 'WalletConnect') {
          if (!walletConnectModal) {
            setStatus(prev => `${prev}WalletConnect not ready. Please refresh.\n`);
            setIsLoading(false);
            return;
          }
          try {
            const wcProvider = await window.EthereumProvider.init({
              projectId: 'YOUR_WALLET_CONNECT_PROJECT_ID',
              chains: [parseInt(selectedNetwork.chainId, 16)],
              optionalChains: networks.map(n => parseInt(n.chainId, 16)),
              showQrModal: true,
              metadata: {
                name: 'Airdrop & Staking App',
                description: 'Web3 Airdrop and Staking Rewards Distribution',
                url: window.location.href,
                icons: ['https://walletconnect.com/walletconnect-logo.png']
              }
            });
            await wcProvider.enable();
            const browserProvider = new ethers.BrowserProvider(wcProvider);
            const signer = await browserProvider.getSigner();
            const accounts = await signer.getAddress();
            setProvider(browserProvider);
            setSigner(signer);
            setAccount(accounts);
            const network = await browserProvider.getNetwork();
            const chainId = `0x${network.chainId.toString(16)}`;
            const selectedNet = networks.find(n => n.chainId === chainId);
            if (selectedNet) {
              setConnectedNetwork(selectedNet);
              setSelectedNetwork(selectedNet);
              wcProvider.on('chainChanged', (chainId) => {
                const net = networks.find(n => n.chainId === chainId);
                if (net) {
                  setConnectedNetwork(net);
                  setSelectedNetwork(net);
                } else {
                  setStatus(prev => `${prev}Switched to unsupported network: ${chainId}\n`);
                }
              });
              wcProvider.on('accountsChanged', (accounts) => {
                if (accounts.length > 0) {
                  setAccount(accounts[0]);
                } else {
                  setIsConnected(false);
                  setAccount(null);
                  setConnectedNetwork(null);
                  setSigner(null);
                  setProvider(null);
                }
              });
            } else {
              setStatus(prev => `${prev}Unsupported network: ${chainId}. Please switch to Cronos Mainnet.\n`);
            }
            setIsConnected(true);
            setStatus(prev => `${prev}Connected to WalletConnect: ${accounts.slice(0, 6)}...${accounts.slice(-4)}\n`);
            walletConnectModal.closeModal();
          } catch (error) {
            setStatus(prev => `${prev}WalletConnect connection failed: ${error.message}\n`);
            walletConnectModal.closeModal();
          }
        }
        setIsLoading(false);
      }, [walletProvider, walletConnectModal, selectedNetwork]);

      const disconnectWallet = () => {
        if (walletProvider === 'WalletConnect' && provider?.provider?.disconnect) {
          provider.provider.disconnect();
        }
        setProvider(null);
        setSigner(null);
        setAccount(null);
        setIsConnected(false);
        setConnectedNetwork(null);
        setStatus(prev => `${prev}Disconnected.\n`);
      };

      const handleNetworkChange = async (e) => {
        const selected = networks.find(n => n.name === e.target.value);
        setSelectedNetwork(selected);
        if (isConnected) {
          try {
            await provider.provider.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: selected.chainId }],
            });
            setConnectedNetwork(selected);
            setStatus(prev => `${prev}Switched to ${selected.name}.\n`);
          } catch (error) {
            if (error.code === 4902) {
              try {
                await provider.provider.request({
                  method: 'wallet_addEthereumChain',
                  params: [{
                    chainId: selected.chainId,
                    chainName: selected.name,
                    nativeCurrency: { name: selected.nativeCurrency, symbol: selected.nativeCurrency, decimals: 18 },
                    rpcUrls: selected.rpcUrls,
                    blockExplorerUrls: selected.blockExplorerUrls
                  }],
                });
                setConnectedNetwork(selected);
                setStatus(prev => `${prev}Added and switched to ${selected.name}.\n`);
              } catch (addError) {
                setStatus(prev => `${prev}Error adding network: ${addError.message}\n`);
              }
            } else {
              setStatus(prev => `${prev}Error switching network: ${error.message}\n`);
            }
          }
        }
      };

      const fetchNFTHolders = async () => {
        if (!provider || !ethers.isAddress(nftContract)) {
          setStatus(prev => `${prev}Please connect wallet and provide a valid NFT contract address.\n`);
          return;
        }
        setIsLoading(true);
        setStatus(prev => `${prev}Fetching NFT holders for contract ${nftContract}...\n`);

        try {
          const contract = new ethers.Contract(nftContract, erc721Abi, provider);
          let holders = new Set();

          if (fetchMethod === 'events') {
            const filter = contract.filters.Transfer(null, null, null);
            const latestBlock = await provider.getBlockNumber();
            const fromBlock = Math.max(latestBlock - 10000, 0); // Limit to recent blocks
            const events = await contract.queryFilter(filter, fromBlock, latestBlock);
            events.forEach(event => {
              const to = event.args.to;
              if (ethers.isAddress(to) && to !== ethers.ZeroAddress) {
                holders.add(to);
              }
            });
            setStatus(prev => `${prev}Fetched ${holders.size} unique holders via Transfer events.\n`);
          } else if (fetchMethod === 'ownerOf') {
            const start = parseInt(tokenIdStart) || 1;
            const end = parseInt(tokenIdEnd) || 100;
            if (end - start > 100) {
              setStatus(prev => `${prev}Token ID range too large (>100). Please reduce range or use CSV upload.\n`);
              setIsLoading(false);
              return;
            }
            for (let tokenId = start; tokenId <= end; tokenId++) {
              try {
                const owner = await contract.ownerOf(tokenId);
                if (ethers.isAddress(owner) && owner !== ethers.ZeroAddress) {
                  holders.add(owner);
                }
              } catch (error) {
                setStatus(prev => `${prev}Skipping token ID ${tokenId}: ${error.message}\n`);
              }
            }
            setStatus(prev => `${prev}Fetched ${holders.size} unique holders for token IDs ${start} to ${end}.\n`);
          }

          const holderList = Array.from(holders).join(',');
          setRecipients(holderList);
          setStatus(prev => `${prev}Set ${holders.size} NFT holder addresses in recipients field.\n`);
        } catch (error) {
          setStatus(prev => `${prev}Error fetching NFT holders: ${error.message}\n`);
        } finally {
          setIsLoading(false);
        }
      };

      const handleFileUpload = (event) => {
        const file = event.target.files[0];
        if (!file) {
          setStatus(prev => `${prev}No file selected.\n`);
          return;
        }
        setIsLoading(true);
        setStatus(prev => `${prev}Reading CSV file...\n`);

        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const text = e.target.result;
            const lines = text.split('\n').map(line => line.trim()).filter(line => line);
            if (lines.length === 0) {
              setStatus(prev => `${prev}CSV file is empty.\n`);
              setIsLoading(false);
              return;
            }
            const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
            if (!headers.includes('address')) {
              setStatus(prev => `${prev}CSV must contain an 'address' column.\n`);
              setIsLoading(false);
              return;
            }
            const addressIndex = headers.indexOf('address');
            const addresses = lines.slice(1).map(line => {
              const cols = line.split(',').map(col => col.trim());
              return cols[addressIndex];
            }).filter(addr => ethers.isAddress(addr));
            if (addresses.length === 0) {
              setStatus(prev => `${prev}No valid addresses found in CSV.\n`);
              setIsLoading(false);
              return;
            }
            setRecipients(addresses.join(','));
            setStatus(prev => `${prev}Loaded ${addresses.length} valid NFT holder addresses from CSV.\n`);
          } catch (error) {
            setStatus(prev => `${prev}Error parsing CSV: ${error.message}\n`);
          } finally {
            setIsLoading(false);
          }
        };
        reader.onerror = () => {
          setStatus(prev => `${prev}Error reading CSV file.\n`);
          setIsLoading(false);
        };
        reader.readAsText(file);
      };

      const sendAirdrop = async () => {
        if (!provider || !signer || !account) {
          setStatus(prev => `${prev}Please connect your wallet first.\n`);
          return;
        }
        if (!ethers || !ethers.parseEther || !ethers.parseUnits || !ethers.isAddress) {
          setStatus(prev => `${prev}Error: Ethers.js library failed to load. Please refresh the page or try an alternative CDN: https://unpkg.com/ethers@6.14.3/dist/ethers.umd.min.js\n`);
          return;
        }
        setIsLoading(true);
        const recipientList = recipients.split(',').map(r => r.trim()).filter(r => ethers.isAddress(r));
        if (recipientList.length === 0) {
          setStatus(prev => `${prev}No valid recipient addresses provided.\n`);
          setIsLoading(false);
          return;
        }
        const batchSizeNum = parseInt(batchSize) || 10;
        const confirm = window.confirm(`Send ${amount} ${tokenType === 'native' ? selectedNetwork.nativeCurrency : 'tokens'} to ${recipientList.length} addresses in batches of ${batchSizeNum}? Confirm each transaction in ${walletProvider}.`);
        if (!confirm) {
          setStatus(prev => `${prev}Airdrop cancelled.\n`);
          setIsLoading(false);
          return;
        }
        setStatus(prev => `${prev}Sending airdrop to ${recipientList.length} addresses in batches of ${batchSizeNum}...\n`);

        try {
          let successCount = 0;
          let nonce = await provider.getTransactionCount(account, 'pending');
          for (let i = 0; i < recipientList.length; i += batchSizeNum) {
            const batch = recipientList.slice(i, i + batchSizeNum);
            for (const recipient of batch) {
              try {
                let feeData;
                try {
                  feeData = await provider.getFeeData();
                } catch (error) {
                  setStatus(prev => `${prev}Warning: Failed to fetch fee data, using fallback gas values: ${error.message}\n`);
                  feeData = {
                    maxFeePerGas: ethers.parseUnits('50', 'gwei'),
                    maxPriorityFeePerGas: ethers.parseUnits('2', 'gwei')
                  };
                }
                if (tokenType === 'native') {
                  let valueInWei;
                  try {
                    valueInWei = ethers.parseEther(amount);
                  } catch (error) {
                    setStatus(prev => `${prev}Invalid amount for CRO transfer: ${amount}. Please enter a valid number.\n`);
                    setIsLoading(false);
                    return;
                  }
                  const tx = {
                    to: recipient,
                    value: valueInWei,
                    gasLimit: await provider.estimateGas({ to: recipient, value: valueInWei }).catch(() => 21000),
                    maxFeePerGas: feeData.maxFeePerGas,
                    maxPriorityFeePerGas: feeData.maxPriorityFeePerGas,
                    nonce: nonce
                  };
                  const txResponse = await signer.sendTransaction(tx);
                  const txReceipt = await txResponse.wait();
                  setStatus(prev => `${prev}Sent ${amount} ${selectedNetwork.nativeCurrency} to ${recipient.slice(0, 6)}...${recipient.slice(-4)}, Tx: ${txReceipt.hash}\n`);
                  successCount++;
                  nonce++;
                } else if (tokenType === 'erc20') {
                  if (!tokenContract || !ethers.isAddress(tokenContract)) {
                    setStatus(prev => `${prev}Invalid or missing token contract address.\n`);
                    setIsLoading(false);
                    return;
                  }
                  const contract = new ethers.Contract(tokenContract, erc20Abi, signer);
                  let decimals;
                  try {
                    decimals = await contract.decimals();
                  } catch (error) {
                    setStatus(prev => `${prev}Warning: Could not fetch token decimals, assuming 18: ${error.message}\n`);
                    decimals = 18;
                  }
                  let amountToken;
                  try {
                    amountToken = ethers.parseUnits(amount, decimals);
                  } catch (error) {
                    setStatus(prev => `${prev}Invalid amount for token transfer: ${amount}. Please enter a valid number.\n`);
                    setIsLoading(false);
                    return;
                  }
                  const tx = {
                    gasLimit: await contract.transfer.estimateGas(recipient, amountToken).catch(() => 60000),
                    maxFeePerGas: feeData.maxFeePerGas,
                    maxPriorityFeePerGas: feeData.maxPriorityFeePerGas,
                    nonce: nonce
                  };
                  const txResponse = await contract.transfer(recipient, amountToken, tx);
                  const txReceipt = await txResponse.wait();
                  setStatus(prev => `${prev}Sent ${amount} tokens to ${recipient.slice(0, 6)}...${recipient.slice(-4)}, Tx: ${txReceipt.hash}\n`);
                  successCount++;
                  nonce++;
                }
                await new Promise(resolve => setTimeout(resolve, 2000));
              } catch (error) {
                setStatus(prev => `${prev}Error sending to ${recipient.slice(0, 6)}...${recipient.slice(-4)}: ${error.message}${error.message.includes('insufficient funds') ? '. Ensure enough CRO for gas and tokens.' : ''}\n`);
              }
            }
          }
          setStatus(prev => `${prev}Completed: Sent airdrop to ${successCount} of ${recipientList.length} addresses.\n`);
        } catch (error) {
          setStatus(prev => `${prev}Airdrop failed: ${error.message}\n`);
        } finally {
          setIsLoading(false);
        }
      };

      return (
        <div className="w-full max-w-4xl bg-white dark:bg-gray-800 rounded-xl shadow-xl p-4 sm:p-6">
          <p className="text-sm text-gray-600 dark:text-gray-400 mb-2">
            Note: WalletConnect requires a project ID from <a href="https://cloud.walletconnect.com/" target="_blank" className="text-blue-500">WalletConnect Cloud</a>.
          </p>
          <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">
            MetaMask is fully supported. Ensure sufficient CRO for gas fees on Cronos.
          </p>

          <div className="mb-6">
            <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-2">Wallet Connection</h2>
            <select
              value={walletProvider}
              onChange={(e) => setWalletProvider(e.target.value)}
              className="w-full sm:w-1/2 p-2 border rounded-lg mb-2"
              disabled={isConnected}
            >
              <option value="MetaMask">MetaMask</option>
              <option value="WalletConnect">WalletConnect</option>
            </select>
            <button
              onClick={isConnected ? disconnectWallet : connectWallet}
              disabled={isLoading}
              className={`w-full sm:w-auto p-2 rounded-lg text-white ${isConnected ? 'bg-red-500 hover:bg-red-600' : 'bg-blue-500 hover:bg-blue-600'} disabled:bg-gray-400`}
              data-tooltip={isConnected ? 'Disconnect your wallet' : 'Connect your wallet'}
            >
              {isLoading ? 'Connecting...' : isConnected ? 'Disconnect' : 'Connect Wallet'}
            </button>
            {isConnected && account && (
              <p className="mt-2 text-gray-700 dark:text-gray-300">
                Connected as: {account.slice(0, 6)}...{account.slice(-4)}
              </p>
            )}
          </div>

          <div className="mb-6">
            <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-2">Network</h2>
            <select
              value={selectedNetwork?.name || networks[0].name}
              onChange={handleNetworkChange}
              className="w-full sm:w-1/2 p-2 border rounded-lg"
              disabled={isLoading}
            >
              {networks.map(n => (
                <option key={n.chainId} value={n.name}>{n.name}</option>
              ))}
            </select>
            {connectedNetwork && (
              <p className="mt-2 text-gray-700 dark:text-gray-300">
                Connected to: {connectedNetwork.name}
              </p>
            )}
          </div>

          <div className="mb-6">
            <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-2">NFT Holders</h2>
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">NFT Contract Address</label>
              <input
                type="text"
                value={nftContract}
                onChange={(e) => setNftContract(e.target.value)}
                placeholder="e.g., 0x..."
                className="mt-1 block w-full rounded-lg border-gray-300 focus:ring-blue-500 focus:border-blue-500"
                disabled={isLoading}
                data-tooltip="Enter the ERC-721 NFT contract address on Cronos"
              />
            </div>
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Fetch Method</label>
              <div className="flex space-x-4">
                <label className="flex items-center">
                  <input
                    type="radio"
                    value="events"
                    checked={fetchMethod === 'events'}
                    onChange={() => setFetchMethod('events')}
                    className="mr-2"
                    disabled={isLoading}
                  />
                  Transfer Events (recent)
                </label>
                <label className="flex items-center">
                  <input
                    type="radio"
                    value="ownerOf"
                    checked={fetchMethod === 'ownerOf'}
                    onChange={() => setFetchMethod('ownerOf')}
                    className="mr-2"
                    disabled={isLoading}
                  />
                  Token ID Range
                </label>
                <label className="flex items-center">
                  <input
                    type="radio"
                    value="csv"
                    checked={fetchMethod === 'csv'}
                    onChange={() => setFetchMethod('csv')}
                    className="mr-2"
                    disabled={isLoading}
                  />
                  Upload CSV
                </label>
              </div>
            </div>
            {fetchMethod === 'ownerOf' && (
              <div className="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Token ID Start</label>
                  <input
                    type="number"
                    value={tokenIdStart}
                    onChange={(e) => setTokenIdStart(e.target.value)}
                    min="1"
                    className="mt-1 block w-full rounded-lg border-gray-300 focus:ring-blue-500 focus:border-blue-500"
                    disabled={isLoading}
                    data-tooltip="Start of token ID range (e.g., 1)"
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Token ID End</label>
                  <input
                    type="number"
                    value={tokenIdEnd}
                    onChange={(e) => setTokenIdEnd(e.target.value)}
                    min="1"
                    className="mt-1 block w-full rounded-lg border-gray-300 focus:ring-blue-500 focus:border-blue-500"
                    disabled={isLoading}
                    data-tooltip="End of token ID range (e.g., 100)"
                  />
                </div>
              </div>
            )}
            {fetchMethod === 'csv' && (
              <div className="mb-4">
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Upload CSV</label>
                <button
                  onClick={() => fileInputRef.current.click()}
                  className="mt-1 p-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 disabled:bg-gray-400"
                  disabled={isLoading}
                  data-tooltip="Upload a CSV file with an 'address' column"
                >
                  Choose CSV File
                </button>
                <input
                  type="file"
                  ref={fileInputRef}
                  onChange={handleFileUpload}
                  accept=".csv"
                  className="hidden"
                  disabled={isLoading}
                />
              </div>
            )}
            {(fetchMethod === 'events' || fetchMethod === 'ownerOf') && (
              <button
                onClick={fetchNFTHolders}
                disabled={isLoading || !nftContract}
                className="mt-2 p-2 rounded-lg bg-blue-500 text-white hover:bg-blue-600 disabled:bg-gray-400"
                data-tooltip="Fetch NFT holder addresses"
              >
                {isLoading ? 'Fetching...' : 'Fetch NFT Holders'}
              </button>
            )}
          </div>

          <div className="mb-6">
            <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-2">Send Airdrop</h2>
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Token Type</label>
              <div className="flex space-x-4">
                <label className="flex items-center">
                  <input
                    type="radio"
                    value="native"
                    checked={tokenType === 'native'}
                    onChange={() => setTokenType('native')}
                    className="mr-2"
                    disabled={isLoading}
                  />
                  Native Token ({selectedNetwork?.nativeCurrency || 'CRO'})
                </label>
                <label className="flex items-center">
                  <input
                    type="radio"
                    value="erc20"
                    checked={tokenType === 'erc20'}
                    onChange={() => setTokenType('erc20')}
                    className="mr-2"
                    disabled={isLoading}
                  />
                  ERC-20 Token
                </label>
              </div>
            </div>
            {tokenType === 'erc20' && (
              <div className="mb-4">
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Token Contract Address</label>
                <input
                  type="text"
                  value={tokenContract}
                  onChange={(e) => setTokenContract(e.target.value)}
                  placeholder="e.g., 0x..."
                  className="mt-1 block w-full rounded-lg border-gray-300 focus:ring-blue-500 focus:border-blue-500"
                  disabled={isLoading}
                  data-tooltip="Enter the ERC-20 token contract address (e.g., LION token on Cronos)"
                />
              </div>
            )}
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Recipients (comma-separated)</label>
                <input
                  type="text"
                  value={recipients}
                  onChange={(e) => setRecipients(e.target.value)}
                  placeholder="e.g., 0x..., 0x..."
                  className="mt-1 block w-full rounded-lg border-gray-300 focus:ring-blue-500 focus:border-blue-500"
                  disabled={isLoading}
                  data-tooltip="Enter comma-separated wallet addresses or fetch from NFT holders"
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                  Amount per Recipient {tokenType === 'native' ? `(${selectedNetwork?.nativeCurrency || 'CRO'})` : '(Tokens)'}
                </label>
                <input
                  type="number"
                  value={amount}
                  onChange={(e) => setAmount(e.target.value)}
                  min="0"
                  step="any"
                  className="mt-1 block w-full rounded-lg border-gray-300 focus:ring-blue-500 focus:border-blue-500"
                  disabled={isLoading}
                  data-tooltip="Enter amount per recipient (e.g., 0.1 CRO or 100 LION)"
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Batch Size</label>
                <input
                  type="number"
                  value={batchSize}
                  onChange={(e) => setBatchSize(e.target.value)}
                  min="1"
                  className="mt-1 block w-full rounded-lg border-gray-300 focus:ring-blue-500 focus:border-blue-500"
                  disabled={isLoading}
                  data-tooltip="Number of transactions per batch (e.g., 10)"
                />
              </div>
            </div>
            <button
              onClick={sendAirdrop}
              disabled={isLoading}
              className="mt-4 w-full sm:w-auto p-2 rounded-lg bg-green-500 text-white hover:bg-green-600 disabled:bg-gray-400"
              data-tooltip="Send airdrop to specified recipients"
            >
              {isLoading ? 'Sending...' : 'Send Airdrop'}
            </button>
          </div>

          <div>
            <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-2">Status</h2>
            <pre className="scrollable-status bg-gray-100 dark:bg-gray-700 p-4 rounded-lg text-sm text-gray-800 dark:text-gray-200 whitespace-pre-wrap">{status}</pre>
          </div>
        </div>
      );
    };

    const root = createRoot(document.getElementById('root'));
    root.render(<AirdropStakingApp />);
  </script>
</body>
</html>
