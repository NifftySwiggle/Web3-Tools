<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/NifftySwiggle/Home/main/assets/NSlogo.png" />
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Airdrop Tool</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.14.3/dist/ethers.umd.min.js" onerror="document.getElementById('root').innerHTML='Error: Failed to load Ethers.js from jsdelivr. Trying fallback...'; fetch('https://unpkg.com/ethers@6.14.3/dist/ethers.umd.min.js').then(res => res.text()).then(text => { const script = document.createElement('script'); script.text = text; document.head.appendChild(script); }).catch(() => document.getElementById('root').innerHTML='Error: Failed to load Ethers.js from fallback CDN.')"></script>
  <script src="https://unpkg.com/@walletconnect/modal@2.7.0/dist/index.min.js"></script>
  <script src="https://unpkg.com/@walletconnect/ethereum-provider@2.21.5/dist/index.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body {
      font-family: 'Inter', sans-serif;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
      background: #4c1d95;
    }
    .stars {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 0;
      overflow: hidden;
    }
    .star {
      position: absolute;
      background: white;
      border-radius: 50%;
      opacity: 0.5;
      animation: twinkle var(--twinkle-duration) infinite linear;
    }
    .star:nth-child(1) { width: 2px; height: 2px; top: 10%; left: 15%; --twinkle-duration: 5s; }
    .star:nth-child(2) { width: 3px; height: 3px; top: 20%; left: 80%; --twinkle-duration: 4s; animation-delay: -1s; }
    .star:nth-child(3) { width: 1px; height: 1px; top: 30%; left: 25%; --twinkle-duration: 6s; animation-delay: -2s; }
    .star:nth-child(4) { width: 2px; height: 2px; top: 40%; left: 70%; --twinkle-duration: 5s; animation-delay: -3s; }
    .star:nth-child(5) { width: 3px; height: 3px; top: 50%; left: 10%; --twinkle-duration: 7s; }
    .star:nth-child(6) { width: 1px; height: 1px; top: 60%; left: 90%; --twinkle-duration: 4s; animation-delay: -4s; }
    .star:nth-child(7) { width: 2px; height: 2px; top: 70%; left: 30%; --twinkle-duration: 6s; animation-delay: -1s; }
    .star:nth-child(8) { width: 3px; height: 3px; top: 80%; left: 85%; --twinkle-duration: 5s; animation-delay: -2s; }
    .star:nth-child(9) { width: 1px; height: 1px; top: 15%; left: 45%; --twinkle-duration: 7s; }
    .star:nth-child(10) { width: 2px; height: 2px; top: 25%; left: 65%; --twinkle-duration: 4s; animation-delay: -3s; }
    .star:nth-child(11) { width: 3px; height: 3px; top: 35%; left: 20%; --twinkle-duration: 6s; }
    .star:nth-child(12) { width: 1px; height: 1px; top: 45%; left: 75%; --twinkle-duration: 5s; animation-delay: -4s; }
    .star:nth-child(13) { width: 2px; height: 2px; top: 55%; left: 35%; --twinkle-duration: 7s; animation-delay: -1s; }
    .star:nth-child(14) { width: 3px; height: 3px; top: 65%; left: 50%; --twinkle-duration: 4s; animation-delay: -2s; }
    .star:nth-child(15) { width: 1px; height: 1px; top: 75%; left: 15%; --twinkle-duration: 6s; }
    .star:nth-child(16) { width: 2px; height: 2px; top: 85%; left: 60%; --twinkle-duration: 5s; animation-delay: -3s; }
    .star:nth-child(17) { width: 3px; height: 3px; top: 20%; left: 40%; --twinkle-duration: 7s; animation-delay: -4s; }
    .star:nth-child(18) { width: 1px; height: 1px; top: 30%; left: 95%; --twinkle-duration: 4s; }
    .star:nth-child(19) { width: 2px; height: 2px; top: 40%; left: 30%; --twinkle-duration: 6s; animation-delay: -1s; }
    .star:nth-child(20) { width: 3px; height: 3px; top: 50%; left: 55%; --twinkle-duration: 5s; animation-delay: -2s; }
    @keyframes twinkle {
      0% { opacity: 0.3; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.2); }
      100% { opacity: 0.3; transform: scale(1); }
    }
    .container {
      background: rgba(31, 41, 55, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 1rem;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      padding: 1.5rem;
      z-index: 1;
      width: 100%;
      max-width: 100%;
      color: #e5e7eb;
      margin: 0 auto;
    }
    @media (min-width: 768px) {
      .container {
        padding: 2rem;
        max-width: 896px;
      }
    }
    @media (min-width: 1024px) {
      .container {
        max-width: 1280px;
        padding: 2.5rem;
      }
      .button-selection-group {
        display: flex;
        flex-direction: row;
        justify-content: flex-start;
        gap: 1rem;
      }
      input, select, button {
        font-size: 1rem;
        padding: 0.75rem;
      }
    }
    @media (max-width: 767px) {
      .container {
        padding: 1rem;
      }
      button, input, select {
        width: 100%;
        margin-top: 0.5rem;
      }
      .holder-row {
        flex-direction: column;
        align-items: flex-start;
      }
      .holder-row button {
        width: 100%;
      }
      .grid-cols-1 {
        grid-template-columns: 1fr;
      }
      .modal {
        width: 95%;
        max-height: 90vh;
      }
      .button-selection-group {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        width: 100%;
        gap: 0.5rem;
      }
      .button-selection-group button {
        width: 100%;
        margin-bottom: 0.5rem;
      }
      .button-group {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
      }
      .button-group button {
        width: 100%;
        margin-bottom: 0.5rem;
      }
    }
    .scrollable-status, .scrollable-preview, .scrollable-history {
      max-height: 300px;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: #6b7280 #374151;
    }
    .scrollable-status::-webkit-scrollbar,
    .scrollable-preview::-webkit-scrollbar,
    .scrollable-history::-webkit-scrollbar {
      width: 8px;
    }
    .scrollable-status::-webkit-scrollbar-track,
    .scrollable-preview::-webkit-scrollbar-track,
    .scrollable-history::-webkit-scrollbar-track {
      background: #374151;
    }
    .scrollable-status::-webkit-scrollbar-thumb,
    .scrollable-preview::-webkit-scrollbar-thumb,
    .scrollable-history::-webkit-scrollbar-thumb {
      background: #6b7280;
      border-radius: 4px;
    }
    .tooltip {
      position: relative;
    }
    .tooltip:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: #111827;
      color: #e5e7eb;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      z-index: 10;
    }
    .modal {
      background: rgba(31, 41, 55, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 1rem;
      max-width: 90%;
      width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      z-index: 1000;
    }
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 999;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .input-error {
      border-color: #ef4444;
    }
    .error-text {
      color: #ef4444;
      font-size: 0.875rem;
    }
    button, input, select {
      transition: all 0.3s ease;
    }
    .selection-button {
      padding: 0.75rem;
      border-radius: 0.5rem;
      font-weight: 500;
      color: #ffffff;
      width: 100%;
      text-align: center;
    }
    .selection-button-selected {
      background-color: #1e40af;
    }
    .selection-button-unselected {
      background-color: #4b5563;
    }
    .selection-button-unselected:hover {
      background-color: #6b7280;
    }
    .selection-button:disabled {
      background-color: #6b7280;
      cursor: not-allowed;
    }
    .history-table {
      width: 100%;
      border-collapse: collapse;
    }
    .history-table th,
    .history-table td {
      padding: 0.75rem;
      border: 1px solid #374151;
      text-align: left;
      font-size: 0.875rem;
    }
    .history-table th {
      background: #374151;
      color: #e5e7eb;
      font-weight: 600;
    }
    .history-table td {
      background: #1f2937;
      color: #d1d5db;
    }
    .history-table a {
      color: #60a5fa;
      text-decoration: none;
    }
    .history-table a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body class="min-h-screen p-4 sm:p-6 lg:p-8 transition-colors duration-300">
  <div class="stars">
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
    <div class="star"></div>
  </div>
  <div id="root" class="container"></div>
  <script type="text/babel">
    const { useState, useEffect, useCallback, useRef, Component } = React;
    const { createRoot } = ReactDOM;
    const { ethers } = window;

    class ErrorBoundary extends Component {
      state = { error: null };
      static getDerivedStateFromError(error) {
        return { error: error.message || 'An unexpected error occurred.' };
      }
      render() {
        if (this.state.error) {
          return (
            <div className="p-4 bg-red-900 text-red-200 rounded-lg">
              <h2 className="text-lg font-semibold">Error</h2>
              <p>{this.state.error}</p>
              <p>Please check the console (F12) for details, clear browser cache, or try refreshing.</p>
            </div>
          );
        }
        return this.props.children;
      }
    }

    const AirdropTool = () => {
      const [provider, setProvider] = useState(null);
      const [signer, setSigner] = useState(null);
      const [account, setAccount] = useState(null);
      const [isConnected, setIsConnected] = useState(false);
      const [selectedNetwork, setSelectedNetwork] = useState(null);
      const [connectedNetwork, setConnectedNetwork] = useState(null);
      const [status, setStatus] = useState('Please connect your wallet to begin.\n');
      const [isLoading, setIsLoading] = useState(false);
      const [walletProvider, setWalletProvider] = useState('MetaMask');
      const [walletConnectModal, setWalletConnectModal] = useState(null);
      const [buttonText, setButtonText] = useState('Connect via MetaMask');
      const [recipients, setRecipients] = useState('');
      const [amount, setAmount] = useState('');
      const [tokenContract, setTokenContract] = useState('');
      const [tokenType, setTokenType] = useState('native');
      const [transferMethod, setTransferMethod] = useState('batch');
      const [nftContract, setNftContract] = useState('');
      const [tokenIds, setTokenIds] = useState('');
      const [fetchMethod, setFetchMethod] = useState('ownerOf');
      const [holderPreview, setHolderPreview] = useState([]);
      const [multipleHoldings, setMultipleHoldings] = useState(false);
      const [txHistory, setTxHistory] = useState([]);
      const [tokenIdsError, setTokenIdsError] = useState('');
      const [amountError, setAmountError] = useState('');
      const [showInstructions, setShowInstructions] = useState(false);
      const [copyTooltip, setCopyTooltip] = useState('Click to copy address');
      const fileInputRef = useRef(null);

      const networks = [
        { chainId: '0x1', name: 'Ethereum Mainnet', rpcUrls: ['https://eth.llamarpc.com'], nativeCurrency: 'ETH', blockExplorerUrls: ['https://etherscan.io'] },
        { chainId: '0x89', name: 'Polygon Mainnet', rpcUrls: ['https://polygon-rpc.com'], nativeCurrency: 'MATIC', blockExplorerUrls: ['https://polygonscan.com'] },
        { chainId: '0x19', name: 'Cronos Mainnet', rpcUrls: ['https://evm.cronos.org', 'https://cronos-rpc.publicnode.com'], nativeCurrency: 'CRO', blockExplorerUrls: ['https://cronoscan.com'] }
      ];

      const erc20Abi = [
        {
          "constant": true,
          "inputs": [],
          "name": "decimals",
          "outputs": [{ "name": "", "type": "uint8" }],
          "type": "function"
        },
        {
          "constant": false,
          "inputs": [
            { "name": "_to", "type": "address" },
            { "name": "_value", "type": "uint256" }
          ],
          "name": "transfer",
          "outputs": [{ "name": "", "type": "bool" }],
          "type": "function"
        },
        {
          "constant": false,
          "inputs": [
            { "name": "spender", "type": "address" },
            { "name": "amount", "type": "uint256" }
          ],
          "name": "approve",
          "outputs": [{ "name": "", "type": "bool" }],
          "type": "function"
        },
        {
          "constant": true,
          "inputs": [
            { "name": "owner", "type": "address" },
            { "name": "spender", "type": "address" }
          ],
          "name": "allowance",
          "outputs": [{ "name": "", "type": "uint256" }],
          "type": "function"
        },
        {
          "constant": true,
          "inputs": [
            { "name": "account", "type": "address" }
          ],
          "name": "balanceOf",
          "outputs": [{ "name": "", "type": "uint256" }],
          "type": "function"
        }
      ];

      const batchTransferAbi = [
        {
          "inputs": [
            { "internalType": "address", "name": "token", "type": "address" },
            { "internalType": "address[]", "name": "recipients", "type": "address[]" },
            { "internalType": "uint256[]", "name": "amounts", "type": "uint256[]" }
          ],
          "name": "batchTransfer",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            { "internalType": "address[]", "name": "recipients", "type": "address[]" },
            { "internalType": "uint256[]", "name": "amounts", "type": "uint256[]" }
          ],
          "name": "batchTransferNative",
          "outputs": [],
          "stateMutability": "payable",
          "type": "function"
        },
        {
          "anonymous": false,
          "inputs": [
            { "indexed": true, "internalType": "address", "name": "sender", "type": "address" },
            { "indexed": true, "internalType": "address", "name": "token", "type": "address" },
            { "indexed": false, "internalType": "address[]", "name": "recipients", "type": "address[]" },
            { "indexed": false, "internalType": "uint256[]", "name": "amounts", "type": "uint256[]" }
          ],
          "name": "BatchTransferExecuted",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            { "indexed": true, "internalType": "address", "name": "sender", "type": "address" },
            { "indexed": false, "internalType": "address[]", "name": "recipients", "type": "address[]" },
            { "indexed": false, "internalType": "uint256[]", "name": "amounts", "type": "uint256[]" }
          ],
          "name": "BatchNativeTransferExecuted",
          "type": "event"
        }
      ];

      const erc721Abi = [
        {
          "constant": true,
          "inputs": [{ "name": "tokenId", "type": "uint256" }],
          "name": "ownerOf",
          "outputs": [{ "name": "", "type": "address" }],
          "type": "function"
        },
        {
          "constant": true,
          "inputs": [],
          "name": "totalSupply",
          "outputs": [{ "name": "", "type": "uint256" }],
          "type": "function"
        },
        {
          "constant": true,
          "inputs": [{ "name": "index", "type": "uint256" }],
          "name": "tokenByIndex",
          "outputs": [{ "name": "", "type": "uint256" }],
          "type": "function"
        }
      ];

      useEffect(() => {
        if (!window.React || !window.ReactDOM || !window.ethers || !window.WalletConnectModal || !window.EthereumProvider) {
          setStatus(prev => `${prev}Error: Missing required dependencies (React, ReactDOM, Ethers.js, WalletConnect). Check console (F12) and Network tab.\n`);
          return;
        }
        const initWalletConnect = async () => {
          const projectId = 'YOUR_WALLET_CONNECT_PROJECT_ID'; // Replace with your actual project ID
          try {
            const modal = new window.WalletConnectModal({
              projectId: projectId,
              themeMode: 'dark',
              themeVariables: { '--wcm-z-index': '1000', '--wcm-accent-color': '#7e22ce' }
            });
            setWalletConnectModal(modal);
            setStatus(prev => `${prev}WalletConnect initialized.\n`);
          } catch (error) {
            setStatus(prev => `${prev}Error initializing WalletConnect: ${error.message}. Please use MetaMask or refresh.\n`);
          }
        };
        initWalletConnect();
        setSelectedNetwork(networks.find(n => n.name === 'Cronos Mainnet'));
      }, []);

      useEffect(() => {
        setButtonText(isConnected ? 'Disconnect' : `Connect via ${walletProvider}`);
      }, [isConnected, walletProvider]);

      const toggleWalletProvider = (e) => {
        e.preventDefault();
        if (!isConnected) {
          setWalletProvider(prev => prev === 'MetaMask' ? 'WalletConnect' : 'MetaMask');
          setStatus(prev => `${prev}Switched to ${walletProvider === 'MetaMask' ? 'WalletConnect' : 'MetaMask'} provider.\n`);
        }
      };

      const parseTokenIds = (input) => {
        const ids = new Set();
        const segments = input.split(',').map(s => s.trim()).filter(s => s);
        for (const segment of segments) {
          if (segment.includes('-') || segment.includes('to')) {
            const separator = segment.includes('-') ? '-' : 'to';
            const [start, end] = segment.split(separator).map(n => parseInt(n.trim()));
            if (isNaN(start) || isNaN(end) || start < 0 || end < 0) {
              throw new Error(`Invalid range: ${segment}`);
            }
            if (start > end) {
              throw new Error(`Invalid range: ${start} > ${end} in ${segment}`);
            }
            for (let i = start; i <= end; i++) {
              ids.add(i);
            }
          } else {
            const id = parseInt(segment);
            if (isNaN(id) || id < 0) {
              throw new Error(`Invalid token ID: ${segment}`);
            }
            ids.add(id);
          }
        }
        return Array.from(ids);
      };

      const validateTokenIds = (input) => {
        if (!input) return '';
        try {
          const ids = parseTokenIds(input);
          if (ids.length === 0) {
            return 'No valid token IDs provided';
          }
          return '';
        } catch (error) {
          return error.message;
        }
      };

      const validateAmount = (value) => {
        if (!value) return '';
        if (isNaN(value) || parseFloat(value) <= 0) {
          return 'Amount must be a positive number';
        }
        return '';
      };

      const connectWallet = useCallback(async () => {
        if (!ethers || !ethers.BrowserProvider || !ethers.isAddress) {
          setStatus(prev => `${prev}Error: Ethers.js not loaded properly. Try alternative CDN: https://unpkg.com/ethers@6.14.3/dist/ethers.umd.min.js\n`);
          setIsLoading(false);
          return;
        }
        setIsLoading(true);
        setStatus(prev => `${prev}Connecting via ${walletProvider}...\n`);
        
        if (walletProvider === 'MetaMask') {
          if (!window.ethereum || !window.ethereum.isMetaMask) {
            setStatus(prev => `${prev}MetaMask not detected. Please install it.\n`);
            setIsLoading(false);
            return;
          }
          try {
            const browserProvider = new ethers.BrowserProvider(window.ethereum);
            const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
            if (accounts.length === 0) {
              setStatus(prev => `${prev}Please unlock MetaMask or grant permission.\n`);
            } else {
              const signer = await browserProvider.getSigner();
              setProvider(browserProvider);
              setSigner(signer);
              setAccount(accounts[0]);
              setIsConnected(true);
              const network = await browserProvider.getNetwork();
              const chainId = `0x${network.chainId.toString(16)}`;
              const selectedNet = networks.find(n => n.chainId === chainId);
              if (selectedNet) {
                setConnectedNetwork(selectedNet);
                setSelectedNetwork(selectedNet);
                window.ethereum.on('chainChanged', (chainId) => {
                  const net = networks.find(n => n.chainId === chainId);
                  if (net) {
                    setConnectedNetwork(net);
                    setSelectedNetwork(net);
                  } else {
                    setStatus(prev => `${prev}Switched to unsupported network: ${chainId}\n`);
                  }
                });
                window.ethereum.on('accountsChanged', (accounts) => {
                  if (accounts.length > 0) {
                    setAccount(accounts[0]);
                  } else {
                    setIsConnected(false);
                    setAccount(null);
                    setConnectedNetwork(null);
                    setSigner(null);
                    setProvider(null);
                  }
                });
              } else {
                setStatus(prev => `${prev}Unsupported network: ${chainId}. Please switch to Cronos Mainnet.\n`);
              }
              setStatus(prev => `${prev}Connected to MetaMask: ${accounts[0].slice(0, 6)}...${accounts[0].slice(-4)}\n`);
            }
          } catch (error) {
            setStatus(prev => `${prev}MetaMask connection failed: ${error.message}\n`);
          }
        } else if (walletProvider === 'WalletConnect') {
          if (!walletConnectModal) {
            setStatus(prev => `${prev}WalletConnect not ready. Please refresh.\n`);
            setIsLoading(false);
            return;
          }
          try {
            const wcProvider = await window.EthereumProvider.init({
              projectId: 'YOUR_WALLET_CONNECT_PROJECT_ID',
              chains: [parseInt(selectedNetwork.chainId, 16)],
              optionalChains: networks.map(n => parseInt(n.chainId, 16)),
              showQrModal: true,
              metadata: {
                name: 'Airdrop Tool',
                description: 'Web3 Airdrop Distribution Tool',
                url: window.location.href,
                icons: ['https://walletconnect.com/walletconnect-logo.png']
              }
            });
            await wcProvider.enable();
            const browserProvider = new ethers.BrowserProvider(wcProvider);
            const signer = await browserProvider.getSigner();
            const accounts = await signer.getAddress();
            setProvider(browserProvider);
            setSigner(signer);
            setAccount(accounts);
            setIsConnected(true);
            const network = await browserProvider.getNetwork();
            const chainId = `0x${network.chainId.toString(16)}`;
            const selectedNet = networks.find(n => n.chainId === chainId);
            if (selectedNet) {
              setConnectedNetwork(selectedNet);
              setSelectedNetwork(selectedNet);
              wcProvider.on('chainChanged', (chainId) => {
                const net = networks.find(n => n.chainId === chainId);
                if (net) {
                  setConnectedNetwork(net);
                  setSelectedNetwork(net);
                } else {
                  setStatus(prev => `${prev}Switched to unsupported network: ${chainId}\n`);
                }
              });
              wcProvider.on('accountsChanged', (accounts) => {
                if (accounts.length > 0) {
                  setAccount(accounts[0]);
                } else {
                  setIsConnected(false);
                  setAccount(null);
                  setConnectedNetwork(null);
                  setSigner(null);
                  setProvider(null);
                }
              });
            } else {
              setStatus(prev => `${prev}Unsupported network: ${chainId}. Please switch to Cronos Mainnet.\n`);
            }
            setStatus(prev => `${prev}Connected to WalletConnect: ${accounts.slice(0, 6)}...${accounts.slice(-4)}\n`);
            walletConnectModal.closeModal();
          } catch (error) {
            setStatus(prev => `${prev}WalletConnect connection failed: ${error.message}\n`);
            walletConnectModal.closeModal();
          }
        }
        setIsLoading(false);
      }, [walletProvider, walletConnectModal, selectedNetwork]);

      const disconnectWallet = () => {
        if (walletProvider === 'WalletConnect' && provider?.provider?.disconnect) {
          provider.provider.disconnect();
        }
        setProvider(null);
        setSigner(null);
        setAccount(null);
        setIsConnected(false);
        setConnectedNetwork(null);
        setStatus(prev => `${prev}Disconnected.\n`);
      };

      const handleWalletAction = () => {
        if (isConnected) {
          disconnectWallet();
        } else {
          connectWallet();
        }
      };

      const handleNetworkChange = async (e) => {
        const selected = networks.find(n => n.name === e.target.value);
        setSelectedNetwork(selected);
        if (isConnected) {
          try {
            await provider.provider.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: selected.chainId }],
            });
            setConnectedNetwork(selected);
            setStatus(prev => `${prev}Switched to ${selected.name}.\n`);
          } catch (error) {
            if (error.code === 4902) {
              try {
                await provider.provider.request({
                  method: 'wallet_addEthereumChain',
                  params: [{
                    chainId: selected.chainId,
                    chainName: selected.name,
                    nativeCurrency: { name: selected.nativeCurrency, symbol: selected.nativeCurrency, decimals: 18 },
                    rpcUrls: selected.rpcUrls,
                    blockExplorerUrls: selected.blockExplorerUrls
                  }],
                });
                setConnectedNetwork(selected);
                setStatus(prev => `${prev}Added and switched to ${selected.name}.\n`);
              } catch (addError) {
                setStatus(prev => `${prev}Error adding network: ${addError.message}\n`);
              }
            } else {
              setStatus(prev => `${prev}Error switching network: ${error.message}\n`);
            }
          }
        }
      };

      const fetchNFTHolders = async () => {
        if (!provider || !ethers.isAddress(nftContract)) {
          setStatus(prev => `${prev}Please connect wallet and provide a valid NFT contract address.\n`);
          return;
        }
        setIsLoading(true);
        setStatus(prev => `${prev}Fetching NFT holders for contract ${nftContract}...\n`);

        try {
          const contract = new ethers.Contract(nftContract, erc721Abi, provider);
          let holdersMap = new Map();

          if (fetchMethod === 'ownerOf') {
            let tokenIdList;
            try {
              tokenIdList = parseTokenIds(tokenIds);
            } catch (error) {
              setStatus(prev => `${prev}${error.message}\n`);
              setIsLoading(false);
              return;
            }
            if (tokenIdList.length === 0) {
              setStatus(prev => `${prev}No valid token IDs provided.\n`);
              setIsLoading(false);
              return;
            }
            const BATCH_SIZE = 100;
            for (let i = 0; i < tokenIdList.length; i += BATCH_SIZE) {
              const batch = tokenIdList.slice(i, i + BATCH_SIZE);
              setStatus(prev => `${prev}Fetching batch ${Math.floor(i / BATCH_SIZE) + 1} of ${Math.ceil(tokenIdList.length / BATCH_SIZE)} (${batch.length} token IDs)...\n`);
              for (const tokenId of batch) {
                try {
                  const owner = await contract.ownerOf(tokenId);
                  if (ethers.isAddress(owner) && owner !== ethers.ZeroAddress) {
                    holdersMap.set(owner, (holdersMap.get(owner) || 0) + 1);
                  }
                } catch (error) {
                  setStatus(prev => `${prev}Skipping token ID ${tokenId}: ${error.message}\n`);
                }
              }
            }
            setStatus(prev => `${prev}Fetched ${holdersMap.size} unique holders for ${tokenIdList.length} token IDs.\n`);
          } else if (fetchMethod === 'entireCollection') {
            try {
              let totalSupply;
              try {
                totalSupply = Number(await contract.totalSupply());
              } catch (error) {
                setStatus(prev => `${prev}Contract does not support totalSupply. Ensure it implements ERC721Enumerable or use Specific Token IDs/CSV upload: ${error.message}\n`);
                setIsLoading(false);
                return;
              }
              if (totalSupply === 0) {
                setStatus(prev => `${prev}No tokens found in the collection.\n`);
                setIsLoading(false);
                return;
              }
              if (totalSupply > 100000) {
                setStatus(prev => `${prev}Collection too large (${totalSupply} tokens). Please use CSV upload or specify token IDs.\n`);
                setIsLoading(false);
                return;
              }
              try {
                await contract.tokenByIndex(0);
              } catch (error) {
                setStatus(prev => `${prev}Contract does not support tokenByIndex. Ensure it implements ERC721Enumerable or use Specific Token IDs/CSV upload: ${error.message}\n`);
                setIsLoading(false);
                return;
              }
              const BATCH_SIZE = 100;
              for (let i = 0; i < totalSupply; i += BATCH_SIZE) {
                const batchEnd = Math.min(i + BATCH_SIZE, totalSupply);
                setStatus(prev => `${prev}Processing batch ${Math.floor(i / BATCH_SIZE) + 1} of ${Math.ceil(totalSupply / BATCH_SIZE)} (tokens ${i} to ${batchEnd - 1})...\n`);
                for (let j = i; j < batchEnd; j++) {
                  try {
                    const tokenId = await contract.tokenByIndex(j);
                    const owner = await contract.ownerOf(tokenId);
                    if (ethers.isAddress(owner) && owner !== ethers.ZeroAddress) {
                      holdersMap.set(owner, (holdersMap.get(owner) || 0) + 1);
                    }
                  } catch (error) {
                    setStatus(prev => `${prev}Skipping token index ${j}: ${error.message}\n`);
                  }
                }
              }
              setStatus(prev => `${prev}Fetched ${holdersMap.size} unique holders for ${totalSupply} tokens in the collection.\n`);
            } catch (error) {
              setStatus(prev => `${prev}Error fetching entire collection: ${error.message}. Ensure the contract supports ERC721Enumerable or use Specific Token IDs/CSV upload.\n`);
              setIsLoading(false);
              return;
            }
          }

          const holderList = Array.from(holdersMap, ([address, count]) => ({ address, count }));
          setHolderPreview(holderList);
          setStatus(prev => `${prev}Preview ${holderList.length} NFT holder addresses below (with NFT counts). Click 'Confirm Holders' to add to recipients.\n`);
        } catch (error) {
          setStatus(prev => `${prev}Error fetching NFT holders: ${error.message}\n`);
        } finally {
          setIsLoading(false);
        }
      };

      const removeHolder = (address) => {
        setHolderPreview(prev => prev.filter(holder => holder.address !== address));
        setStatus(prev => `${prev}Removed address ${address.slice(0, 6)}...${address.slice(-4)} from preview.\n`);
      };

      const confirmHolders = () => {
        if (holderPreview.length === 0) {
          setStatus(prev => `${prev}No holders to confirm. Please fetch NFT holders first.\n`);
          return;
        }
        const holderList = holderPreview.map(holder => ({ address: holder.address, count: holder.count }));
        setHolderPreview(holderList);
        setRecipients(holderList.map(h => h.address).join(','));
        setStatus(prev => `${prev}Confirmed ${holderList.length} unique NFT holder addresses${multipleHoldings ? ' (with NFT counts)' : ''} added to recipients.\n`);
      };

      const handleFileUpload = (event) => {
        const file = event.target.files[0];
        if (!file) {
          setStatus(prev => `${prev}No file selected.\n`);
          setIsLoading(false);
          return;
        }
        setIsLoading(true);
        setStatus(prev => `${prev}Reading CSV file...\n`);

        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const text = e.target.result;
            const lines = text.split('\n').map(line => line.trim()).filter(line => line);
            if (lines.length === 0) {
              setStatus(prev => `${prev}CSV file is empty.\n`);
              setIsLoading(false);
              return;
            }
            const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
            if (!headers.includes('address')) {
              setStatus(prev => `${prev}CSV must contain an 'address' column.\n`);
              setIsLoading(false);
              return;
            }
            const addressIndex = headers.indexOf('address');
            const addresses = lines.slice(1).map(line => {
              const cols = line.split(',').map(col => col.trim());
              return cols[addressIndex];
            }).filter(addr => ethers.isAddress(addr));
            if (addresses.length === 0) {
              setStatus(prev => `${prev}No valid addresses found in CSV.\n`);
              setIsLoading(false);
              return;
            }
            const holdersMap = new Map();
            addresses.forEach(addr => {
              holdersMap.set(addr, (holdersMap.get(addr) || 0) + 1);
            });
            const holderList = Array.from(holdersMap, ([address, count]) => ({ address, count }));
            setHolderPreview(holderList);
            setStatus(prev => `${prev}Loaded ${holderList.length} valid NFT holder addresses from CSV (with NFT counts). Click 'Confirm Holders' to add to recipients.\n`);
          } catch (error) {
            setStatus(prev => `${prev}Error parsing CSV: ${error.message}\n`);
            setIsLoading(false);
          }
        };
        reader.onerror = () => {
          setStatus(prev => `${prev}Error reading CSV file.\n`);
          setIsLoading(false);
        };
        reader.readAsText(file);
      };

      const sendAirdrop = async () => {
        if (!provider || !signer || !account || !isConnected) {
          setStatus(prev => `${prev}Please connect your wallet first.\n`);
          return;
        }
        if (!ethers || !ethers.parseEther || !ethers.parseUnits || !ethers.isAddress) {
          setStatus(prev => `${prev}Error: Ethers.js not loaded properly. Try alternative CDN: https://unpkg.com/ethers@6.14.3/dist/ethers.umd.min.js\n`);
          return;
        }
        const amountErr = validateAmount(amount);
        if (amountErr) {
          setAmountError(amountErr);
          setStatus(prev => `${prev}Invalid amount: ${amountErr}\n`);
          return;
        }
        setAmountError('');
        const recipientList = multipleHoldings
          ? holderPreview.length > 0
            ? holderPreview
            : recipients.split(',').map(r => ({ address: r.trim(), count: 1 })).filter(r => ethers.isAddress(r.address))
          : recipients.split(',').map(r => ({ address: r.trim(), count: 1 })).filter(r => ethers.isAddress(r.address));
        if (recipientList.length === 0) {
          setStatus(prev => `${prev}No valid recipient addresses provided. ${multipleHoldings ? 'Please fetch and confirm NFT holders.' : 'Please enter valid addresses in the Recipients field or fetch NFT holders.'}\n`);
          return;
        }
        const totalAmount = recipientList.reduce((sum, holder) => sum + holder.count * parseFloat(amount), 0);
        const confirmMessage = tokenType === 'native'
          ? transferMethod === 'batch'
            ? `Send ${totalAmount} ${selectedNetwork.nativeCurrency} to ${recipientList.length} unique addresses${multipleHoldings ? ' (accounting for NFT counts)' : ''} in one batch transaction? Confirm one transaction in ${walletProvider}.`
            : `Send ${totalAmount} ${selectedNetwork.nativeCurrency} to ${recipientList.length} unique addresses${multipleHoldings ? ' (accounting for NFT counts)' : ''}? Confirm ${recipientList.length} transaction${recipientList.length > 1 ? 's' : ''} in ${walletProvider}.`
          : transferMethod === 'batch'
            ? `Send ${totalAmount} tokens to ${recipientList.length} unique addresses${multipleHoldings ? ' (accounting for NFT counts)' : ''} in one batch transaction? You may need to approve the contract first, then confirm one batch transaction in ${walletProvider}.`
            : `Send ${totalAmount} tokens to ${recipientList.length} unique addresses${multipleHoldings ? ' (accounting for NFT counts)' : ''}? Confirm ${recipientList.length} transaction${recipientList.length > 1 ? 's' : ''} (one per recipient) in ${walletProvider}${recipientList.length > 1 ? ', and you may need to approve the contract first' : ''}.`;
        const confirm = window.confirm(confirmMessage);
        if (!confirm) {
          setStatus(prev => `${prev}Airdrop cancelled.\n`);
          return;
        }
        setIsLoading(true);
        setStatus(prev => `${prev}Sending airdrop to ${recipientList.length} unique addresses${multipleHoldings ? ' (with NFT counts)' : ''}...\n`);

        try {
          if (tokenType === 'native') {
            if (transferMethod === 'batch') {
              const batchContractAddress = '0x99594c35f74eFE963C567434C530b1441EF7ff3e'; // REPLACE WITH ACTUAL DEPLOYED CONTRACT ADDRESS
              const batchContract = new ethers.Contract(batchContractAddress, batchTransferAbi, signer);
              const recipientAddresses = recipientList.map(r => r.address);
              const amounts = recipientList.map(r => ethers.parseEther((parseFloat(amount) * r.count).toString()));
              const totalAmountWei = amounts.reduce((sum, amt) => sum + BigInt(amt), 0n);
              const balance = await provider.getBalance(account);
              if (balance < totalAmountWei) {
                setStatus(prev => `${prev}Insufficient ${selectedNetwork.nativeCurrency} balance for ${totalAmount} ${selectedNetwork.nativeCurrency}.\n`);
                setIsLoading(false);
                return;
              }
              let gasLimit;
              try {
                gasLimit = await batchContract.batchTransferNative.estimateGas(recipientAddresses, amounts, { value: totalAmountWei });
                gasLimit = (BigInt(gasLimit) * BigInt(12) / BigInt(10)).toString();
              } catch (error) {
                gasLimit = (100000 * recipientList.length).toString();
                setStatus(prev => `${prev}Warning: Failed to estimate gas, using fallback value: ${error.message}\n`);
              }
              try {
                const tx = await batchContract.batchTransferNative(recipientAddresses, amounts, { value: totalAmountWei, gasLimit });
                const txReceipt = await tx.wait();
                setStatus(prev => `${prev}Batch airdrop successful: Sent ${totalAmount} ${selectedNetwork.nativeCurrency} to ${recipientList.length} addresses, Tx: ${txReceipt.hash}\n`);
                setTxHistory(prev => [...prev, {
                  recipient: `${recipientList.length} addresses`,
                  amount: totalAmount,
                  token: selectedNetwork.nativeCurrency,
                  txHash: txReceipt.hash,
                  timestamp: new Date().toLocaleString(),
                  explorer: `${selectedNetwork.blockExplorerUrls[0]}/tx/${txReceipt.hash}`
                }]);
              } catch (error) {
                setStatus(prev => `${prev}Error in batch native airdrop: ${error.message}${error.message.includes('insufficient funds') ? '. Ensure enough CRO for gas and transfer amount.' : ''}\n`);
              }
            } else {
              let successCount = 0;
              for (let i = 0; i < recipientList.length; i++) {
                const recipient = recipientList[i];
                const amountWei = ethers.parseEther((parseFloat(amount) * recipient.count).toString());
                setStatus(prev => `${prev}Sending ${amount * recipient.count} ${selectedNetwork.nativeCurrency} to ${recipient.address} (transaction ${i + 1}/${recipientList.length})...\n`);
                try {
                  const tx = await signer.sendTransaction({
                    to: recipient.address,
                    value: amountWei
                  });
                  const txReceipt = await tx.wait();
                  setStatus(prev => `${prev}Sent ${amount * recipient.count} ${selectedNetwork.nativeCurrency} to ${recipient.address}, Tx: ${txReceipt.hash}\n`);
                  setTxHistory(prev => [...prev, {
                    recipient: recipient.address,
                    amount: amount * recipient.count,
                    token: selectedNetwork.nativeCurrency,
                    txHash: txReceipt.hash,
                    timestamp: new Date().toLocaleString(),
                    explorer: `${selectedNetwork.blockExplorerUrls[0]}/tx/${txReceipt.hash}`
                  }]);
                  successCount++;
                } catch (error) {
                  setStatus(prev => `${prev}Error sending to ${recipient.address}: ${error.message}${error.message.includes('insufficient funds') ? '. Ensure enough CRO for gas and transfer amount.' : ''}\n`);
                }
              }
              setStatus(prev => `${prev}Completed airdrop: ${successCount}/${recipientList.length} transactions successful.\n`);
            }
          } else if (tokenType === 'erc20') {
            if (!tokenContract || !ethers.isAddress(tokenContract)) {
              setStatus(prev => `${prev}Invalid or missing token contract address.\n`);
              setIsLoading(false);
              return;
            }
            const tokenContractInstance = new ethers.Contract(tokenContract, erc20Abi, signer);
            let decimals;
            try {
              decimals = await tokenContractInstance.decimals();
            } catch (error) {
              setStatus(prev => `${prev}Warning: Could not fetch token decimals, assuming 18: ${error.message}\n`);
              decimals = 18;
            }
            let totalAmountWei;
            try {
              totalAmountWei = ethers.parseUnits(totalAmount.toString(), decimals);
            } catch (error) {
              setStatus(prev => `${prev}Invalid amount for token transfer: ${totalAmount}. Please enter a valid number.\n`);
              setIsLoading(false);
              return;
            }
            const balance = await tokenContractInstance.balanceOf(account);
            if (balance < totalAmountWei) {
              setStatus(prev => `${prev}Insufficient token balance for ${totalAmount} tokens.\n`);
              setIsLoading(false);
              return;
            }
            if (transferMethod === 'batch') {
              const batchContractAddress = '0x99594c35f74eFE963C567434C530b1441EF7ff3e'; // REPLACE WITH ACTUAL DEPLOYED CONTRACT ADDRESS
              const batchContract = new ethers.Contract(batchContractAddress, batchTransferAbi, signer);
              const allowance = await tokenContractInstance.allowance(account, batchContractAddress);
              if (allowance < totalAmountWei) {
                setStatus(prev => `${prev}Approving batch contract to spend ${totalAmount} tokens...\n`);
                try {
                  const approveTx = await tokenContractInstance.approve(batchContractAddress, totalAmountWei);
                  await approveTx.wait();
                  setStatus(prev => `${prev}Approval successful.\n`);
                } catch (error) {
                  setStatus(prev => `${prev}Error approving tokens: ${error.message}\n`);
                  setIsLoading(false);
                  return;
                }
              }
              const recipientAddresses = recipientList.map(r => r.address);
              const amounts = recipientList.map(r => ethers.parseUnits((parseFloat(amount) * r.count).toString(), decimals));
              let gasLimit;
              try {
                gasLimit = await batchContract.batchTransfer.estimateGas(tokenContract, recipientAddresses, amounts);
                gasLimit = (BigInt(gasLimit) * BigInt(12) / BigInt(10)).toString();
              } catch (error) {
                gasLimit = (100000 * recipientList.length).toString();
                setStatus(prev => `${prev}Warning: Failed to estimate gas, using fallback value: ${error.message}\n`);
              }
              try {
                const tx = await batchContract.batchTransfer(tokenContract, recipientAddresses, amounts, { gasLimit });
                const txReceipt = await tx.wait();
                setStatus(prev => `${prev}Batch airdrop successful: Sent ${totalAmount} tokens to ${recipientList.length} addresses, Tx: ${txReceipt.hash}\n`);
                setTxHistory(prev => [...prev, {
                  recipient: `${recipientList.length} addresses`,
                  amount: totalAmount,
                  token: 'ERC-20',
                  txHash: txReceipt.hash,
                  timestamp: new Date().toLocaleString(),
                  explorer: `${selectedNetwork.blockExplorerUrls[0]}/tx/${txReceipt.hash}`
                }]);
              } catch (error) {
                setStatus(prev => `${prev}Error in batch airdrop: ${error.message}${error.message.includes('insufficient funds') ? '. Ensure enough CRO for gas.' : ''}\n`);
              }
            } else if (transferMethod === 'individual') {
              let successCount = 0;
              for (let i = 0; i < recipientList.length; i++) {
                const recipient = recipientList[i];
                const amountWei = ethers.parseUnits((parseFloat(amount) * recipient.count).toString(), decimals);
                setStatus(prev => `${prev}Sending ${amount * recipient.count} tokens to ${recipient.address} (transaction ${i + 1}/${recipientList.length})...\n`);
                try {
                  const tx = await tokenContractInstance.transfer(recipient.address, amountWei);
                  const txReceipt = await tx.wait();
                  setStatus(prev => `${prev}Sent ${amount * recipient.count} tokens to ${recipient.address}, Tx: ${txReceipt.hash}\n`);
                  setTxHistory(prev => [...prev, {
                    recipient: recipient.address,
                    amount: amount * recipient.count,
                    token: 'ERC-20',
                    txHash: txReceipt.hash,
                    timestamp: new Date().toLocaleString(),
                    explorer: `${selectedNetwork.blockExplorerUrls[0]}/tx/${txReceipt.hash}`
                  }]);
                  successCount++;
                } catch (error) {
                  setStatus(prev => `${prev}Error sending to ${recipient.address}: ${error.message}${error.message.includes('insufficient funds') ? '. Ensure enough CRO for gas.' : ''}\n`);
                }
              }
              setStatus(prev => `${prev}Completed airdrop: ${successCount}/${recipientList.length} transactions successful.\n`);
            }
          }
        } catch (error) {
          setStatus(prev => `${prev}Airdrop failed: ${error.message}\n`);
        } finally {
          setIsLoading(false);
        }
      };

      const resetForm = () => {
        setRecipients('');
        setAmount('');
        setTokenContract('');
        setTokenType('native');
        setTransferMethod('batch');
        setNftContract('');
        setTokenIds('');
        setFetchMethod('ownerOf');
        setHolderPreview([]);
        setMultipleHoldings(false);
        setTokenIdsError('');
        setAmountError('');
        setStatus(prev => `${prev}Form reset.\n`);
      };

      const copyToClipboard = async () => {
        try {
          await navigator.clipboard.writeText('0x99594c35f74eFE963C567434C530b1441EF7ff3e');
          setCopyTooltip('Address copied!');
          setTimeout(() => setCopyTooltip('Click to copy address'), 2000);
        } catch (error) {
          setCopyTooltip('Failed to copy address');
          setTimeout(() => setCopyTooltip('Click to copy address'), 2000);
          setStatus(prev => `${prev}Error copying address: ${error.message}\n`);
        }
      };

      const InstructionsModal = () => (
        <div className="modal-overlay">
          <div className="modal p-6 text-gray-200">
            <h2 className="text-xl font-semibold text-white mb-4">How to Use the Airdrop Tool</h2>
            <ol className="list-decimal list-inside space-y-2 text-sm">
              <li><strong>Connect Wallet</strong>: Click the wallet button to connect via MetaMask or WalletConnect (right-click to toggle provider). Ensure you're on Cronos Mainnet (or another supported network).</li>
              <li><strong>Select Network</strong>: Choose a network (e.g., Cronos Mainnet). The app will prompt you to switch if needed.</li>
              <li><strong>Fetch NFT Holders</strong>:
                <ul className="list-disc list-inside ml-4">
                  <li><strong>Specific Token IDs</strong>: Enter comma-separated token IDs or ranges (e.g., 1to5,7,9to10 or 1-5,7,9-10 or 1,3,5) for an NFT contract. Processed in batches of 100 for large lists.</li>
                  <li><strong>Entire Collection</strong>: Enter an ERC721Enumerable contract address to fetch all token holders (requires totalSupply and tokenByIndex). Processed in batches of 100 for large collections.</li>
                  <li><strong>CSV Upload</strong>: Upload a CSV with an 'address' column containing wallet addresses.</li>
                </ul>
              </li>
              <li><strong>Preview Holders</strong>: After fetching, review the list of holders and their NFT counts. Remove any unwanted addresses.</li>
              <li><strong>Confirm Holders</strong>: Click "Confirm Holders" to add addresses to the Recipients field.</li>
              <li><strong>Configure Airdrop</strong>:
                <ul className="list-disc list-inside ml-4">
                  <li><strong>Token Type</strong>: Choose Native Token (e.g., CRO) or ERC-20 Token (enter token contract address).</li>
                  <li><strong>Transfer Method</strong>: Choose Batch Transfer (one transaction) or Individual Transfers (one transaction per recipient) for either token type.</li>
                  <li><strong>Recipients</strong>: Addresses are auto-filled from confirmed holders or manually entered (comma-separated).</li>
                  <li><strong>Amount</strong>: Enter the amount per recipient or per NFT (if "Airdrop per NFT Held" is checked).</li>
                  <li><strong>Airdrop per NFT Held</strong>: If enabled, each holder receives the amount multiplied by their NFT count.</li>
                </ul>
              </li>
              <li><strong>Send Airdrop</strong>: Click "Send Airdrop". For Batch Transfer, confirm one transaction (plus approval for ERC-20 if needed). For Individual Transfers, confirm one transaction per recipient (plus approval for ERC-20 if needed). Monitor progress in the Status section.</li>
              <li><strong>View History</strong>: Check sent transactions in the Transaction History section with links to Cronosscan.</li>
              <li><strong>Reset Form</strong>: Clear all inputs and start over if needed.</li>
            </ol>
            <p className="mt-4 text-sm text-gray-400">
              <strong>Tips</strong>: Test on Cronos Testnet to avoid using real funds. Ensure your wallet has enough CRO for gas fees and transfer amounts (for native tokens). For ERC721Enumerable issues, use CSV upload or specific token IDs.
            </p>
            <button
              onClick={() => setShowInstructions(false)}
              className="mt-4 p-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium w-full"
            >
              Close
            </button>
          </div>
        </div>
      );

      return (
        <ErrorBoundary>
          <div className="w-full max-w-4xl lg:max-w-5xl">
            <header className="mb-6 text-center">
              <h1 className="text-3xl font-bold text-white">Airdrop Tool</h1>
              <button
                onClick={() => setShowInstructions(true)}
                className="mt-2 p-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium tooltip"
                data-tooltip="View instructions on how to use the app"
              >
                How to Use the App
              </button>
            </header>
            {showInstructions && <InstructionsModal />}
            <div className="mb-8">
              <h2 className="text-xl font-semibold text-white mb-3">Wallet Connection</h2>
              <div className="button-group">
                <button
                  onClick={handleWalletAction}
                  onContextMenu={toggleWalletProvider}
                  disabled={isLoading}
                  className={`p-3 rounded-lg text-white font-medium ${isConnected ? 'bg-red-600 hover:bg-red-700' : 'bg-blue-600 hover:bg-blue-700'} disabled:bg-gray-500 tooltip`}
                  data-tooltip={isConnected ? 'Disconnect your wallet' : 'Click to connect; right-click to toggle provider'}
                >
                  {isLoading ? 'Connecting...' : buttonText}
                </button>
              </div>
              {isConnected && account && (
                <p className="mt-2 text-gray-300">
                  Connected as: <span className="font-mono">{account.slice(0, 6)}...{account.slice(-4)}</span>
                </p>
              )}
            </div>

            <div className="mb-8">
              <h2 className="text-xl font-semibold text-white mb-3">Network</h2>
              <select
                value={selectedNetwork?.name || networks[0].name}
                onChange={handleNetworkChange}
                className="w-full sm:w-1/2 p-3 border border-gray-600 rounded-lg focus:ring-blue-500 focus:border-blue-500 bg-gray-700 text-white"
                disabled={isLoading}
              >
                {networks.map(n => (
                  <option key={n.chainId} value={n.name}>{n.name}</option>
                ))}
              </select>
              {connectedNetwork && (
                <p className="mt-2 text-gray-300">
                  Connected to: {connectedNetwork.name}
                </p>
              )}
            </div>

            <div className="mb-8">
              <h2 className="text-xl font-semibold text-white mb-3">NFT Holders</h2>
              <div className="mb-4">
                <label className="block text-sm font-medium text-gray-300">NFT Contract Address</label>
                <input
                  type="text"
                  value={nftContract}
                  onChange={(e) => setNftContract(e.target.value)}
                  placeholder="e.g., 0x..."
                  className={`mt-1 block w-full p-3 rounded-lg border border-gray-600 focus:ring-blue-500 focus:border-blue-500 bg-gray-700 text-white ${!ethers.isAddress(nftContract) && nftContract ? 'input-error' : ''}`}
                  disabled={isLoading}
                  data-tooltip="Enter the ERC-721 NFT contract address on Cronos"
                />
                {!ethers.isAddress(nftContract) && nftContract && (
                  <p className="error-text mt-1">Invalid contract address</p>
                )}
              </div>
              <div className="mb-4">
                <label className="block text-sm font-medium text-gray-300 mb-1">Fetch Method</label>
                <div className="button-selection-group">
                  <button
                    onClick={() => setFetchMethod('ownerOf')}
                    disabled={isLoading}
                    className={`selection-button ${fetchMethod === 'ownerOf' ? 'selection-button-selected' : 'selection-button-unselected'} disabled:bg-gray-500 tooltip`}
                    data-tooltip="Fetch holders by specific token IDs"
                  >
                    Specific Token IDs
                  </button>
                  <button
                    onClick={() => setFetchMethod('entireCollection')}
                    disabled={isLoading}
                    className={`selection-button ${fetchMethod === 'entireCollection' ? 'selection-button-selected' : 'selection-button-unselected'} disabled:bg-gray-500 tooltip`}
                    data-tooltip="Fetch all holders of an ERC721Enumerable collection"
                  >
                    Entire Collection (ERC721Enumerable required)
                  </button>
                  <button
                    onClick={() => setFetchMethod('csv')}
                    disabled={isLoading}
                    className={`selection-button ${fetchMethod === 'csv' ? 'selection-button-selected' : 'selection-button-unselected'} disabled:bg-gray-500 tooltip`}
                    data-tooltip="Upload a CSV file with holder addresses"
                  >
                    Upload CSV
                  </button>
                </div>
              </div>
              {fetchMethod === 'ownerOf' && (
                <div className="mb-4">
                  <label className="block text-sm font-medium text-gray-300">Token IDs (comma-separated or ranges)</label>
                  <input
                    type="text"
                    value={tokenIds}
                    onChange={(e) => {
                      setTokenIds(e.target.value);
                      setTokenIdsError(validateTokenIds(e.target.value));
                    }}
                    placeholder="e.g., 1to5,7,9to10 or 1-5,7,9-10 or 1,3,5"
                    className={`mt-1 block w-full p-3 rounded-lg border border-gray-600 focus:ring-blue-500 focus:border-blue-500 bg-gray-700 text-white ${tokenIdsError ? 'input-error' : ''}`}
                    disabled={isLoading}
                    data-tooltip="Enter comma-separated token IDs or ranges (e.g., 1to5,7,9to10 or 1-5,7,9-10 or 1,3,5). Processed in batches of 100."
                  />
                  <p className="text-sm text-gray-400 mt-1">Processed in batches of 100 token IDs.</p>
                  {tokenIdsError && <p className="error-text mt-1">{tokenIdsError}</p>}
                </div>
              )}
              {fetchMethod === 'csv' && (
                <div className="mb-4">
                  <label className="block text-sm font-medium text-gray-300">Upload CSV</label>
                  <button
                    onClick={() => fileInputRef.current.click()}
                    className="mt-1 p-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-500 font-medium tooltip"
                    disabled={isLoading}
                    data-tooltip="Upload a CSV file with an 'address' column"
                  >
                    Choose CSV File
                  </button>
                  <input
                    type="file"
                    ref={fileInputRef}
                    onChange={handleFileUpload}
                    accept=".csv"
                    className="hidden"
                    disabled={isLoading}
                  />
                </div>
              )}
              <div className="mb-4">
                <label className="block text-sm font-medium text-gray-300 mb-1">Airdrop per NFT Held</label>
                <div className="button-selection-group">
                  <button
                    onClick={() => setMultipleHoldings(!multipleHoldings)}
                    disabled={isLoading}
                    className={`selection-button ${multipleHoldings ? 'selection-button-selected' : 'selection-button-unselected'} disabled:bg-gray-500 tooltip`}
                    data-tooltip="Toggle to airdrop amount per NFT held"
                  >
                    {multipleHoldings ? 'Enabled: Airdrop per NFT Held' : 'Disabled: Airdrop per Recipient'}
                  </button>
                </div>
                <p className="text-sm text-gray-400 mt-1">
                  If enabled, each holder receives the airdrop amount multiplied by their NFT count.
                </p>
              </div>
              {(fetchMethod === 'ownerOf' || fetchMethod === 'entireCollection' || fetchMethod === 'csv') && (
                <button
                  onClick={fetchNFTHolders}
                  disabled={isLoading || (!ethers.isAddress(nftContract) && (fetchMethod === 'ownerOf' || fetchMethod === 'entireCollection')) || (fetchMethod === 'ownerOf' && tokenIdsError)}
                  className="mt-2 p-3 rounded-lg bg-blue-600 text-white hover:bg-blue-700 disabled:bg-gray-500 font-medium tooltip"
                  data-tooltip="Fetch NFT holder addresses"
                >
                  {isLoading ? 'Fetching...' : 'Fetch NFT Holders'}
                </button>
              )}
              {holderPreview.length > 0 && (
                <div className="mt-4">
                  <h3 className="text-lg font-semibold text-white mb-2">Preview NFT Holders</h3>
                  <div className="scrollable-preview bg-gray-700 p-4 rounded-lg text-sm text-gray-200">
                    {holderPreview.map((holder, index) => (
                      <div key={index} className="holder-row flex items-center justify-between mb-2">
                        <span className="font-mono">{holder.address} (x{holder.count} NFT{holder.count > 1 ? 's' : ''})</span>
                        <button
                          onClick={() => removeHolder(holder.address)}
                          className="p-1 bg-red-600 text-white rounded hover:bg-red-700 text-xs font-medium tooltip"
                          data-tooltip="Remove this address from the preview"
                        >
                          Remove
                        </button>
                      </div>
                    ))}
                  </div>
                  <button
                    onClick={confirmHolders}
                    className="mt-2 p-3 rounded-lg bg-green-600 text-white hover:bg-green-700 font-medium tooltip"
                    data-tooltip="Add previewed holders to recipients"
                  >
                    Confirm Holders
                  </button>
                </div>
              )}
            </div>

            <div className="mb-8">
              <h2 className="text-xl font-semibold text-white mb-3">Send Airdrop</h2>
              <div className="mb-4">
                <label className="block text-sm font-medium text-gray-300 mb-1">Token Type</label>
                <div className="button-selection-group">
                  <button
                    onClick={() => setTokenType('native')}
                    disabled={isLoading}
                    className={`selection-button ${tokenType === 'native' ? 'selection-button-selected' : 'selection-button-unselected'} disabled:bg-gray-500 tooltip`}
                    data-tooltip={`Select ${selectedNetwork?.nativeCurrency || 'CRO'} as the token to airdrop`}
                  >
                    Native Token ({selectedNetwork?.nativeCurrency || 'CRO'})
                  </button>
                  <button
                    onClick={() => setTokenType('erc20')}
                    disabled={isLoading}
                    className={`selection-button ${tokenType === 'erc20' ? 'selection-button-selected' : 'selection-button-unselected'} disabled:bg-gray-500 tooltip`}
                    data-tooltip="Select an ERC-20 token to airdrop"
                  >
                    ERC-20 Token
                  </button>
                </div>
              </div>
              <div className="mb-4">
                <label className="block text-sm font-medium text-gray-300 mb-1">Transfer Method</label>
                <div className="button-selection-group">
                  <button
                    onClick={() => setTransferMethod('batch')}
                    disabled={isLoading}
                    className={`selection-button ${transferMethod === 'batch' ? 'selection-button-selected' : 'selection-button-unselected'} disabled:bg-gray-500 tooltip`}
                    data-tooltip="Send airdrop in one transaction"
                  >
                    Batch Transfer (1 transaction)
                  </button>
                  <button
                    onClick={() => setTransferMethod('individual')}
                    disabled={isLoading}
                    className={`selection-button ${transferMethod === 'individual' ? 'selection-button-selected' : 'selection-button-unselected'} disabled:bg-gray-500 tooltip`}
                    data-tooltip="Send airdrop with one transaction per recipient"
                  >
                    Individual Transfers (1 per recipient)
                  </button>
                </div>
              </div>
              {tokenType === 'erc20' && (
                <div className="mb-4">
                  <label className="block text-sm font-medium text-gray-300">Token Contract Address</label>
                  <input
                    type="text"
                    value={tokenContract}
                    onChange={(e) => setTokenContract(e.target.value)}
                    placeholder="e.g., 0x..."
                    className={`mt-1 block w-full p-3 rounded-lg border border-gray-600 focus:ring-blue-500 focus:border-blue-500 bg-gray-700 text-white ${!ethers.isAddress(tokenContract) && tokenContract ? 'input-error' : ''}`}
                    disabled={isLoading}
                    data-tooltip="Enter the ERC-20 token contract address"
                  />
                  {!ethers.isAddress(tokenContract) && tokenContract && (
                    <p className="error-text mt-1">Invalid token contract address</p>
                  )}
                </div>
              )}
              <div className="mb-4">
                <label className="block text-sm font-medium text-gray-300">Recipients (comma-separated)</label>
                <input
                  type="text"
                  value={recipients}
                  onChange={(e) => setRecipients(e.target.value)}
                  placeholder="e.g., 0x123...,0x456..."
                  className="mt-1 block w-full p-3 rounded-lg border border-gray-600 focus:ring-blue-500 focus:border-blue-500 bg-gray-700 text-white"
                  disabled={isLoading}
                  data-tooltip="Enter comma-separated wallet addresses or fetch from NFT holders"
                />
              </div>
              <div className="mb-4">
                <label className="block text-sm font-medium text-gray-300">Amount per Recipient</label>
                <input
                  type="text"
                  value={amount}
                  onChange={(e) => {
                    setAmount(e.target.value);
                    setAmountError(validateAmount(e.target.value));
                  }}
                  placeholder={`e.g., 1.0 (${selectedNetwork?.nativeCurrency || 'CRO'} or tokens)`}
                  className={`mt-1 block w-full p-3 rounded-lg border border-gray-600 focus:ring-blue-500 focus:border-blue-500 bg-gray-700 text-white ${amountError ? 'input-error' : ''}`}
                  disabled={isLoading}
                  data-tooltip="Enter the amount per recipient (or per NFT if 'Airdrop per NFT Held' is checked)"
                />
                {amountError && <p className="error-text mt-1">{amountError}</p>}
              </div>
              <div className="flex flex-col sm:flex-row sm:space-x-4 space-y-2 sm:space-y-0 button-group">
                <button
                  onClick={sendAirdrop}
                  disabled={isLoading || amountError || (tokenType === 'erc20' && (!ethers.isAddress(tokenContract) || !tokenContract))}
                  className="p-3 rounded-lg bg-blue-600 text-white hover:bg-blue-700 disabled:bg-gray-500 font-medium tooltip"
                  data-tooltip="Send the airdrop to recipients"
                >
                  {isLoading ? 'Sending...' : 'Send Airdrop'}
                </button>
                <button
                  onClick={resetForm}
                  disabled={isLoading}
                  className="p-3 rounded-lg bg-gray-600 text-white hover:bg-gray-700 disabled:bg-gray-500 font-medium tooltip"
                  data-tooltip="Clear all inputs and reset the form"
                >
                  Reset Form
                </button>
              </div>
            </div>

            <div className="mb-8">
              <h2 className="text-xl font-semibold text-white mb-3">Status</h2>
              <div className="scrollable-status bg-gray-700 p-4 rounded-lg text-sm text-gray-200">
                <pre className="font-mono whitespace-pre-wrap">{status}</pre>
              </div>
            </div>

            <div className="mb-8">
              <h2 className="text-xl font-semibold text-white mb-3">Transaction History</h2>
              {txHistory.length > 0 ? (
                <div className="scrollable-history bg-gray-700 p-4 rounded-lg">
                  <table className="history-table">
                    <thead>
                      <tr>
                        <th>Recipient</th>
                        <th>Amount</th>
                        <th>Token</th>
                        <th>Tx Hash</th>
                        <th>Timestamp</th>
                      </tr>
                    </thead>
                    <tbody>
                      {txHistory.map((tx, index) => (
                        <tr key={index}>
                          <td>{tx.recipient.length > 20 ? `${tx.recipient.slice(0, 6)}...${tx.recipient.slice(-4)}` : tx.recipient}</td>
                          <td>{tx.amount}</td>
                          <td>{tx.token}</td>
                          <td>
                            <a
                              href={tx.explorer}
                              target="_blank"
                              rel="noopener noreferrer"
                              className="font-mono"
                            >
                              {tx.txHash.slice(0, 6)}...{tx.txHash.slice(-4)}
                            </a>
                          </td>
                          <td>{tx.timestamp}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              ) : (
                <p className="text-gray-300">No transactions yet.</p>
              )}
            </div>

            <footer className="mt-8 text-center text-gray-400 text-sm">
              <p>
                Developed By <a href="https://x.com/pet_rescueNFT" target="_blank" rel="noopener noreferrer" className="text-blue-400 hover:underline">NifftySwiggle</a> 
              </p>
             <p>
                Enjoying the tool? Consider donating to support development:
              </p>
              <p>
                <a href="#" onClick={(e) => {
                  e.preventDefault();
                  navigator.clipboard.writeText("0x71074075bA6FFE0BF39aCb6EDEF09b3b6be3AB6f")
                    .then(() => alert("Address copied to clipboard!"))
                    .catch(err => console.error("Copy failed:", err));
                }} className="text-blue-400 hover:underline">
                  Copy Donate Wallet
                </a>
              </p>

            </footer>
          </div>
        </ErrorBoundary>
      );
    };

    const root = createRoot(document.getElementById('root'));
    root.render(<AirdropTool />);
  </script>
</body>
</html>


