<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cryptocurrency Airdrop & Staking App</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/web3@4.4.0/dist/web3.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body { font-family: 'Inter', sans-serif; }
    .scrollable-status {
      max-height: 200px; overflow-y: auto; scrollbar-width: thin; scrollbar-color: #4b5563 #e5e7eb;
    }
    .scrollable-status::-webkit-scrollbar { width: 8px; }
    .scrollable-status::-webkit-scrollbar-track { background: #e5e7eb; }
    .scrollable-status::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
    .tooltip { position: relative; }
    .tooltip:hover::after {
      content: attr(data-tooltip); position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%);
      background: #1f2937; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px;
      white-space: nowrap; z-index: 10;
    }
  </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 min-h-screen flex items-center justify-center p-4 transition-colors duration-300">
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useCallback } = React;
    const { createRoot } = ReactDOM;
    const { Web3 } = window;

    const AirdropStakingApp = () => {
      const [web3, setWeb3] = useState(null);
      const [account, setAccount] = useState(null);
      const [network, setNetwork] = useState('Cronos Mainnet');
      const [recipients, setRecipients] = useState('');
      const [amount, setAmount] = useState('');
      const [tokenContract, setTokenContract] = useState('');
      const [tokenType, setTokenType] = useState('native');
      const [tokenIds, setTokenIds] = useState('');
      const [status, setStatus] = useState('Welcome! Follow these steps:\n1. Click "Test Connection" to verify RPC.\n2. Click "Connect Wallet" to link MetaMask (approve in MetaMask).\n3. Ensure Cronos Mainnet is selected.\n4. Enter your NFT contract address and token IDs.\n5. Fetch holders and send airdrops or rewards.\nIf MetaMask disconnects, click "Reconnect Wallet", update MetaMask, or try a custom RPC (e.g., https://cronos-rpc.publicnode.com).\n');
      const [isLoading, setIsLoading] = useState(false);
      const [nftContract, setNftContract] = useState('');
      const [startTokenId, setStartTokenId] = useState('1');
      const [endTokenId, setEndTokenId] = useState('5');
      const [specificTokenIds, setSpecificTokenIds] = useState('');
      const [useSpecificIds, setUseSpecificIds] = useState(false);
      const [nftHolders, setNftHolders] = useState([]);
      const [rewardType, setRewardType] = useState('native');
      const [rewardAmount, setRewardAmount] = useState('');
      const [rewardTokenContract, setRewardTokenContract] = useState('');
      const [theme, setTheme] = useState('light');
      const [customRpc, setCustomRpc] = useState('');
      const [batchSize, setBatchSize] = useState('2');

      const networks = [
        {
          chainId: '0x19',
          name: 'Cronos Mainnet',
          nativeCurrency: 'CRO',
          blockTime: 5.6,
          genesisBlock: 1000000,
          rpcUrls: ['https://evm.cronos.org', 'https://cronos-rpc.publicnode.com', 'https://rpc-cronos.mms.team'],
          blockExplorerUrls: ['https://cronoscan.com']
        },
        {
          chainId: '0x1',
          name: 'Ethereum Mainnet',
          nativeCurrency: 'ETH',
          blockTime: 12,
          genesisBlock: 0,
          rpcUrls: ['https://eth.llamarpc.com'],
          blockExplorerUrls: ['https://etherscan.io']
        },
        {
          chainId: '0x89',
          name: 'Polygon Mainnet',
          nativeCurrency: 'MATIC',
          blockTime: 2,
          genesisBlock: 0,
          rpcUrls: ['https://polygon-rpc.com'],
          blockExplorerUrls: ['https://polygonscan.com']
        },
        {
          chainId: '0x38',
          name: 'BNB Chain',
          nativeCurrency: 'BNB',
          blockTime: 3,
          genesisBlock: 0,
          rpcUrls: ['https://bsc-dataseed.binance.org'],
          blockExplorerUrls: ['https://bscscan.com']
        },
        {
          chainId: '0xa4b1',
          name: 'Arbitrum One',
          nativeCurrency: 'ETH',
          blockTime: 0.25,
          genesisBlock: 0,
          rpcUrls: ['https://arb1.arbitrum.io/rpc'],
          blockExplorerUrls: ['https://arbiscan.io']
        },
        {
          chainId: '0xa',
          name: 'Optimism',
          nativeCurrency: 'ETH',
          blockTime: 2,
          genesisBlock: 0,
          rpcUrls: ['https://mainnet.optimism.io'],
          blockExplorerUrls: ['https://optimistic.etherscan.io']
        }
      ];

      const erc20Abi = [
        {
          "constant": false,
          "inputs": [{ "name": "_to", "type": "address" }, { "name": "_value", "type": "uint256" }],
          "name": "transfer",
          "outputs": [{ "name": "success", "type": "bool" }],
          "type": "function"
        }
      ];

      const erc721Abi = [
        {
          "constant": true,
          "inputs": [{ "name": "_tokenId", "type": "uint256" }],
          "name": "ownerOf",
          "outputs": [{ "name": "owner", "type": "address" }],
          "type": "function"
        },
        {
          "constant": true,
          "inputs": [],
          "name": "totalSupply",
          "outputs": [{ "name": "", "type": "uint256" }],
          "type": "function"
        },
        {
          "constant": false,
          "inputs": [{ "name": "_from", "type": "address" }, { "name": "_to", "type": "address" }, { "name": "_tokenId", "type": "uint256" }],
          "name": "transferFrom",
          "outputs": [],
          "type": "function"
        }
      ];

      const toggleTheme = () => {
        setTheme(theme === 'light' ? 'dark' : 'light');
        document.documentElement.classList.toggle('dark');
      };

      const checkMetaMaskConnection = () => {
        return window.ethereum && window.ethereum.isConnected();
      };

      const reconnectMetaMask = async (retries = 12, delay = 5000) => {
        for (let i = 0; i < retries; i++) {
          if (checkMetaMaskConnection()) return true;
          setStatus(prev => `${prev}MetaMask disconnected. Attempting to reconnect (${i + 1}/${retries})...\n`);
          try {
            await window.ethereum.request({ method: 'eth_requestAccounts' });
            setStatus(prev => `${prev}MetaMask reconnected successfully.\n`);
            return true;
          } catch (error) {
            setStatus(prev => `${prev}Reconnect attempt ${i + 1} failed: ${error.message}. Retrying after ${delay}ms...\n`);
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        }
        setStatus(prev => `${prev}Failed to reconnect MetaMask after ${retries} attempts. Please reload the page, click "Reconnect Wallet", ensure MetaMask is unlocked, or try a custom RPC (e.g., https://cronos-rpc.publicnode.com).\n`);
        return false;
      };

      const validateRpcUrl = async (rpcUrl) => {
        try {
          const web3Test = new Web3(rpcUrl);
          await web3Test.eth.getChainId();
          return true;
        } catch (error) {
          setStatus(prev => `${prev}Invalid RPC URL: ${rpcUrl}. Trying fallback RPC...\n`);
          return false;
        }
      };

      const getValidRpcUrl = async (rpcUrls) => {
        for (const rpcUrl of rpcUrls) {
          const isValid = await validateRpcUrl(rpcUrl);
          if (isValid) return rpcUrl;
        }
        setStatus(prev => `${prev}All RPC URLs failed. Please try a custom RPC (e.g., https://cronos-rpc.publicnode.com) or check your internet connection.\n`);
        return rpcUrls[0];
      };

      useEffect(() => {
        const checkExistingConnection = async () => {
          if (checkMetaMaskConnection()) {
            try {
              const accounts = await window.ethereum.request({ method: 'eth_accounts' });
              if (accounts.length > 0) {
                const selectedNetwork = networks.find(n => n.name === network);
                const rpcUrl = await getValidRpcUrl(selectedNetwork.rpcUrls);
                const web3Instance = new Web3(rpcUrl);
                setWeb3(web3Instance);
                setAccount(accounts[0]);
                const chainId = await web3Instance.eth.getChainId();
                const matchedNetwork = networks.find(n => n.chainId === `0x${chainId.toString(16)}`) || { name: 'Unknown', nativeCurrency: 'Unknown', blockTime: 12 };
                setNetwork(matchedNetwork.name);
                setTokenType('native');
                setRewardType('native');
                setStatus(prev => `${prev}Detected existing MetaMask connection: ${accounts[0].slice(0, 6)}...${accounts[0].slice(-4)}. Select Cronos Mainnet and enter your NFT contract to continue.\n`);
              }
            } catch (error) {
              setStatus(prev => `${prev}Error checking existing MetaMask connection: ${error.message}. Click "Connect Wallet" to try again.\n`);
            }
          }
        };
        checkExistingConnection();
      }, []);

      useEffect(() => {
        const interval = setInterval(async () => {
          if (!checkMetaMaskConnection()) {
            setStatus(prev => `${prev}MetaMask disconnected. Please click "Reconnect Wallet" or reload the page.\n`);
            setAccount(null);
            setWeb3(null);
          }
        }, 5000);
        return () => clearInterval(interval);
      }, []);

      const testConnection = async () => {
        setIsLoading(true);
        setStatus(prev => `${prev}Testing RPC and wallet connection...\n`);

        const selectedNetwork = networks.find(n => n.name === network);
        let rpcUrl = customRpc || await getValidRpcUrl(selectedNetwork.rpcUrls);

        try {
          const web3Test = new Web3(rpcUrl);
          const chainId = await web3Test.eth.getChainId();
          if (parseInt(chainId) !== parseInt(selectedNetwork.chainId, 16)) {
            setStatus(prev => `${prev}Error: RPC chain ID (${chainId}) does not match selected network (${selectedNetwork.chainId}). Please use a valid Cronos RPC (e.g., https://cronos-rpc.publicnode.com).\n`);
            setIsLoading(false);
            return;
          }
          setStatus(prev => `${prev}Success: RPC connection to ${rpcUrl} is working.\n`);

          if (checkMetaMaskConnection()) {
            try {
              await window.ethereum.request({ method: 'eth_requestAccounts' });
              setStatus(prev => `${prev}Success: MetaMask is available and responsive.\n`);
            } catch (error) {
              setStatus(prev => `${prev}Error: MetaMask failed to respond: ${error.message}. Try updating MetaMask, disabling conflicting extensions, or using a custom RPC.\n`);
            }
          } else {
            setStatus(prev => `${prev}Error: MetaMask not detected. Please ensure MetaMask is installed and unlocked.\n`);
          }
        } catch (error) {
          setStatus(prev => `${prev}Error testing RPC connection: ${error.message}. Try a different RPC (e.g., https://cronos-rpc.publicnode.com) or check your internet connection.\n`);
        } finally {
          setIsLoading(false);
        }
      };

      const connectWallet = useCallback(async () => {
        if (!window.ethereum) {
          setStatus(prev => `${prev}Error: MetaMask not detected. Please install MetaMask and refresh the page.\n`);
          return;
        }

        setIsLoading(true);
        setStatus(prev => `${prev}Attempting to connect MetaMask...\n`);

        const selectedNetwork = networks.find(n => n.name === network);
        const rpcUrl = customRpc || await getValidRpcUrl(selectedNetwork.rpcUrls);

        try {
          const web3Instance = new Web3(rpcUrl);
          await window.ethereum.request({ method: 'eth_requestAccounts' });
          const accounts = await web3Instance.eth.getAccounts();
          if (accounts.length > 0) {
            setWeb3(web3Instance);
            setAccount(accounts[0]);
            const chainId = await web3Instance.eth.getChainId();
            const matchedNetwork = networks.find(n => n.chainId === `0x${chainId.toString(16)}`) || { name: 'Unknown', nativeCurrency: 'Unknown', blockTime: 12 };
            setNetwork(matchedNetwork.name);
            setTokenType('native');
            setRewardType('native');
            setStatus(prev => `${prev}MetaMask connected successfully: ${accounts[0].slice(0, 6)}...${accounts[0].slice(-4)}. Select Cronos Mainnet and enter your NFT contract to continue.\n`);
          } else {
            setStatus(prev => `${prev}No accounts returned from MetaMask. Please ensure MetaMask is unlocked and try again.\n`);
          }
        } catch (error) {
          setStatus(prev => `${prev}Error connecting to MetaMask: ${error.message}${error.message.includes('User rejected') ? '. Please approve the connection in MetaMask.' : error.message.includes('Premature close') ? '. Try updating MetaMask, reloading the page, or using a different RPC.' : ''}. Check browser console for details.\n`);
          console.error('MetaMask connection error:', error);
        } finally {
          setIsLoading(false);
        }
      }, [network, customRpc]);

      useEffect(() => {
        if (window.ethereum) {
          const handleAccountsChanged = async (accounts) => {
            if (!checkMetaMaskConnection()) {
              setStatus(prev => `${prev}MetaMask disconnected. Please click "Reconnect Wallet" or reload the page.\n`);
              setAccount(null);
              setWeb3(null);
              return;
            }
            if (accounts.length > 0) {
              setAccount(accounts[0]);
              setStatus(prev => `${prev}Wallet account changed: ${accounts[0].slice(0, 6)}...${accounts[0].slice(-4)}. Ready to proceed.\n`);
            } else {
              disconnectWallet();
            }
          };

          const handleChainChanged = async (chainId) => {
            if (!checkMetaMaskConnection()) {
              setStatus(prev => `${prev}MetaMask disconnected. Please click "Reconnect Wallet" or reload the page.\n`);
              setAccount(null);
              setWeb3(null);
              return;
            }
            const selectedNetwork = networks.find(n => n.chainId === chainId) || { name: 'Unknown', nativeCurrency: 'Unknown', blockTime: 12 };
            setNetwork(selectedNetwork.name);
            setTokenType('native');
            setRewardType('native');
            setStatus(prev => `${prev}Network changed to ${selectedNetwork.name}. Enter your NFT contract to fetch holders.\n`);
            try {
              const accounts = await window.ethereum.request({ method: 'eth_accounts' });
              if (accounts.length > 0) {
                setAccount(accounts[0]);
              }
            } catch (error) {
              setStatus(prev => `${prev}Error fetching accounts after network change: ${error.message}.\n`);
            }
          };

          window.ethereum.on('accountsChanged', handleAccountsChanged);
          window.ethereum.on('chainChanged', handleChainChanged);
          window.ethereum.on('connect', () => {
            setStatus(prev => `${prev}MetaMask connected. Checking accounts...\n`);
            handleAccountsChanged([]);
          });
          window.ethereum.on('disconnect', () => {
            setStatus(prev => `${prev}MetaMask disconnected. Please click "Reconnect Wallet" or reload the page.\n`);
            disconnectWallet();
          });

          return () => {
            window.ethereum.removeListener('accountsChanged', handleAccountsChanged);
            window.ethereum.removeListener('chainChanged', handleChainChanged);
            window.ethereum.removeListener('connect', handleAccountsChanged);
            window.ethereum.removeListener('disconnect', disconnectWallet);
          };
        }
      }, []);

      const switchNetwork = async (chainId) => {
        try {
          if (!checkMetaMaskConnection()) {
            setStatus(prev => `${prev}MetaMask is disconnected. Please click "Reconnect Wallet" or reload the page.\n`);
            return;
          }
          const network = networks.find(n => n.chainId === chainId);
          const rpcUrl = customRpc || await getValidRpcUrl(network.rpcUrls);

          try {
            await window.ethereum.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId }]
            });
          } catch (switchError) {
            if (switchError.code === 4902) {
              await window.ethereum.request({
                method: 'wallet_addEthereumChain',
                params: [{
                  chainId: chainId,
                  chainName: network.name,
                  nativeCurrency: {
                    name: network.nativeCurrency,
                    symbol: network.nativeCurrency,
                    decimals: 18
                  },
                  rpcUrls: [rpcUrl],
                  blockExplorerUrls: network.blockExplorerUrls
                }]
              });
            } else {
              throw switchError;
            }
          }
          const selectedNetwork = networks.find(n => n.chainId === chainId) || { name: 'Unknown', nativeCurrency: 'Unknown', blockTime: 12 };
          setNetwork(selectedNetwork.name);
          setTokenType('native');
          setRewardType('native');
          setStatus(prev => `${prev}Switched to ${selectedNetwork.name}. Enter your NFT contract to fetch holders.\n`);
        } catch (error) {
          setStatus(prev => `${prev}Error switching network: ${error.message}${error.message.includes('Premature close') ? '. Try updating MetaMask, reloading the page, or using a different RPC.' : ''}. Please try again.\n`);
        }
      };

      const disconnectWallet = () => {
        setAccount(null);
        setWeb3(null);
        setNetwork('Cronos Mainnet');
        setRecipients('');
        setAmount('');
        setTokenContract('');
        setTokenType('native');
        setTokenIds('');
        setNftContract('');
        setStartTokenId('1');
        setEndTokenId('5');
        setSpecificTokenIds('');
        setUseSpecificIds(false);
        setNftHolders([]);
        setRewardType('native');
        setRewardAmount('');
        setRewardTokenContract('');
        setCustomRpc('');
        setBatchSize('2');
        setStatus(prev => `${prev}Wallet disconnected. Click "Test Connection" then "Connect Wallet" to reconnect and start again.\n`);
      };

      const fetchNftHolders = async () => {
        if (!web3 || !account) {
          setStatus(prev => `${prev}Wallet not connected. Please click "Connect Wallet" and ensure MetaMask is unlocked.\n`);
          return;
        }

        if (!checkMetaMaskConnection()) {
          const reconnected = await reconnectMetaMask();
          if (!reconnected) {
            setStatus(prev => `${prev}Cannot proceed with fetching NFT holders. Please reconnect your wallet.\n`);
            return;
          }
        }

        if (!web3.utils.isAddress(nftContract)) {
          setStatus(prev => `${prev}Invalid NFT contract address. Please enter a valid address (e.g., 0x...) and verify it on Cronoscan (https://cronoscan.com).\n`);
          return;
        }

        let tokenIdList = [];
        if (useSpecificIds) {
          tokenIdList = specificTokenIds.split(',').map(id => parseInt(id.trim())).filter(id => !isNaN(id) && id >= 0);
          if (tokenIdList.length === 0) {
            setStatus(prev => `${prev}Please provide valid comma-separated token IDs (e.g., 1,2,3).\n`);
            return;
          }
        } else {
          const start = parseInt(startTokenId);
          const end = parseInt(endTokenId);
          if (isNaN(start) || isNaN(end) || start > end || start < 0) {
            setStatus(prev => `${prev}Invalid token ID range. Start must be less than or equal to end and non-negative (e.g., 1 to 5).\n`);
            return;
          }
          tokenIdList = Array.from({ length: end - start + 1 }, (_, i) => start + i);
        }

        if (tokenIdList.length > 5) {
          setStatus(prev => `${prev}Too many token IDs (max 5). Please reduce the range or use specific IDs to avoid wallet issues.\n`);
          return;
        }

        setIsLoading(true);
        setStatus(prev => `${prev}Fetching NFT holders for ${tokenIdList.length} tokens...\n`);
        setNftHolders([]);

        const retry = async (fn, retries = 5, baseDelay = 1000) => {
          for (let i = 0; i < retries; i++) {
            if (!checkMetaMaskConnection()) {
              setStatus(prev => `${prev}MetaMask disconnected during operation. Please click "Reconnect Wallet" or reload the page.\n`);
              return;
            }
            try {
              return await fn();
            } catch (error) {
              if (i === retries - 1) throw error;
              setStatus(prev => `${prev}Retrying operation (${i + 1}/${retries}) after ${baseDelay * Math.pow(2, i)}ms...\n`);
              await new Promise(resolve => setTimeout(resolve, baseDelay * Math.pow(2, i)));
            }
          }
        };

        try {
          const selectedNetwork = networks.find(n => n.name === network);
          const rpcUrl = customRpc || await getValidRpcUrl(selectedNetwork.rpcUrls);
          const web3Instance = new Web3(rpcUrl);
          setWeb3(web3Instance);
          const contract = new web3Instance.eth.Contract(erc721Abi, nftContract);

          const holders = [];
          for (const tokenId of tokenIdList) {
            try {
              const owner = await retry(() => contract.methods.ownerOf(tokenId).call());
              holders.push({ tokenId, owner });
              setStatus(prev => `${prev}Fetched owner for token ${tokenId}: ${owner.slice(0, 6)}...${owner.slice(-4)}.\n`);
            } catch (error) {
              setStatus(prev => `${prev}Error fetching owner for token ${tokenId}: ${error.message}. Possibly unminted or invalid token. Skipping.\n`);
            }
            await new Promise(resolve => setTimeout(resolve, 200));
          }

          if (holders.length === 0) {
            setStatus(prev => `${prev}No valid holders found for the specified token IDs. Check the contract address on Cronoscan (https://cronoscan.com) or try different token IDs (e.g., 1 to 5).\n`);
            setIsLoading(false);
            return;
          }

          setNftHolders(holders);
          setStatus(prev => `${prev}Fetched ${holders.length} NFT holders successfully.\n`);
        } catch (error) {
          setStatus(prev => `${prev}Error fetching NFT holders: ${error.message}. Please check the contract address, use a premium RPC (e.g., QuickNode), or verify on Cronoscan (https://cronoscan.com).\n`);
        } finally {
          setIsLoading(false);
        }
      };

      const sendBatchNativeRewards = async () => {
        if (!web3 || !account) {
          setStatus(prev => `${prev}Wallet not connected. Please click "Connect Wallet" and ensure MetaMask is unlocked.\n`);
          return;
        }

        if (!checkMetaMaskConnection()) {
          const reconnected = await reconnectMetaMask(12, 5000);
          if (!reconnected) {
            setStatus(prev => `${prev}Cannot proceed with reward distribution. Please reload the page, click "Reconnect Wallet", and ensure MetaMask is unlocked.\n`);
            setIsLoading(false);
            return;
          }
        }

        if (nftHolders.length === 0) {
          setStatus(prev => `${prev}No NFT holders fetched. Please fetch holders first using a valid NFT contract address.\n`);
          return;
        }

        if (!rewardAmount || isNaN(rewardAmount) || parseFloat(rewardAmount) <= 0) {
          setStatus(prev => `${prev}Invalid reward amount. Please enter a positive number (e.g., 1 CRO).\n`);
          return;
        }

        const batchSizeNum = parseInt(batchSize);
        if (isNaN(batchSizeNum) || batchSizeNum < 1 || batchSizeNum > 3) {
          setStatus(prev => `${prev}Invalid batch size. Please enter a number between 1 and 3.\n`);
          return;
        }

        if (nftHolders.length > batchSizeNum) {
          setStatus(prev => `${prev}Too many NFT holders (max ${batchSizeNum}). Please fetch a smaller range of token IDs or increase the batch size.\n`);
          return;
        }

        const confirm = window.confirm(`Are you sure you want to send ${rewardAmount} CRO to ${nftHolders.length} NFT holders? Confirm each transaction in MetaMask.`);
        if (!confirm) {
          setStatus(prev => `${prev}Reward distribution cancelled by user.\n`);
          return;
        }

        setIsLoading(true);
        setStatus(prev => `${prev}Preparing to send native rewards to ${nftHolders.length} NFT holders (batch size: ${batchSizeNum})... Please confirm each transaction in MetaMask and keep the MetaMask window open.\n`);

        try {
          const selectedNetwork = networks.find(n => n.name === network);
          const rpcUrl = customRpc || await getValidRpcUrl(selectedNetwork.rpcUrls);
          const web3Instance = new Web3(rpcUrl);
          setWeb3(web3Instance);

          try {
            await web3Instance.eth.getChainId();
            setStatus(prev => `${prev}RPC connection validated: ${rpcUrl}.\n`);
          } catch (error) {
            setStatus(prev => `${prev}RPC validation failed: ${error.message}. Switching to fallback RPC or use a custom RPC (e.g., https://cronos-rpc.publicnode.com).\n`);
            const fallbackRpc = await getValidRpcUrl(selectedNetwork.rpcUrls.filter(url => url !== rpcUrl));
            setWeb3(new Web3(fallbackRpc));
            setStatus(prev => `${prev}Switched to fallback RPC: ${fallbackRpc}.\n`);
          }

          let nonce = await web3Instance.eth.getTransactionCount(account, 'pending');
          const amountWei = web3Instance.utils.toWei(rewardAmount, 'ether');
          const validRecipients = nftHolders.map(h => h.owner).filter(addr => web3.utils.isAddress(addr));
          let successCount = 0;

          for (let i = 0; i < validRecipients.length; i++) {
            if (!checkMetaMaskConnection()) {
              const reconnected = await reconnectMetaMask(12, 5000);
              if (!reconnected) {
                setStatus(prev => `${prev}MetaMask disconnected during reward distribution. Please reload the page, click "Reconnect Wallet", ensure MetaMask is unlocked, and try again.\n`);
                setIsLoading(false);
                return;
              }
            }

            const recipient = validRecipients[i];
            const amount = (BigInt(amountWei) / BigInt(nftHolders.length)).toString();

            if (BigInt(amount) <= 0) {
              setStatus(prev => `${prev}Skipping ${recipient}: Invalid or zero amount.\n`);
              continue;
            }

            const tx = {
              from: account,
              to: recipient,
              value: amount,
              gas: 25000,
              gasPrice: await web3Instance.eth.getGasPrice(),
              nonce: nonce
            };

            try {
              setStatus(prev => `${prev}Awaiting MetaMask signature for ${web3Instance.utils.fromWei(amount, 'ether')} ${selectedNetwork?.nativeCurrency || 'CRO'} to ${recipient.slice(0, 6)}...${recipient.slice(-4)}...\n`);
              const txHash = await new Promise((resolve, reject) => {
                let attempts = 0;
                const maxAttempts = 4;
                const timeoutMs = 30000;

                const trySend = async () => {
                  const timeout = setTimeout(() => {
                    reject(new Error('Transaction timed out: MetaMask did not respond within 30 seconds.'));
                  }, timeoutMs);

                  try {
                    const result = await window.ethereum.request({
                      method: 'eth_sendTransaction',
                      params: [tx]
                    });
                    clearTimeout(timeout);
                    resolve(result);
                  } catch (error) {
                    clearTimeout(timeout);
                    attempts++;
                    if (attempts >= maxAttempts || (!error.message.includes('Premature close') && !error.message.includes('timed out'))) {
                      reject(error);
                      return;
                    }
                    setStatus(prev => `${prev}Transaction attempt ${attempts} failed for ${recipient.slice(0, 6)}...${recipient.slice(-4)}: ${error.message}. Retrying after 6s...\n`);
                    await new Promise(resolve => setTimeout(resolve, 6000));
                    trySend();
                  }
                };
                trySend();
              });

              setStatus(prev => `${prev}Success: Sent ${web3Instance.utils.fromWei(amount, 'ether')} ${selectedNetwork?.nativeCurrency || 'CRO'} to ${recipient.slice(0, 6)}...${recipient.slice(-4)}, Tx Hash: ${txHash}\n`);
              successCount++;
              nonce++;
              await new Promise(resolve => setTimeout(resolve, 6000));
            } catch (error) {
              setStatus(prev => `${prev}Error sending ${web3Instance.utils.fromWei(amount, 'ether')} ${selectedNetwork?.nativeCurrency || 'CRO'} to ${recipient.slice(0, 6)}...${recipient.slice(-4)}: ${error.message}${error.message.includes('Premature close') || error.message.includes('timed out') ? '. Please reload the page, ensure MetaMask is unlocked, and try a reliable RPC (e.g., https://cronos-rpc.publicnode.com or QuickNode).' : error.message.includes('insufficient funds') ? '. Ensure your wallet has enough CRO for gas and rewards.' : ''}\n`);
            }
          }

          setStatus(prev => `${prev}Completed: Sent native rewards to ${successCount} of ${validRecipients.length} NFT holders.\n`);
        } catch (error) {
          setStatus(prev => `${prev}Native reward distribution failed: ${error.message}${error.message.includes('Premature close') || error.message.includes('timed out') ? '. Please reload the page, ensure MetaMask is unlocked, and try a reliable RPC (e.g., https://cronos-rpc.publicnode.com or QuickNode).' : error.message.includes('insufficient funds') ? '. Ensure your wallet has enough CRO for gas and rewards.' : ''}. Try a smaller batch size (e.g., 1) or a different RPC.\n`);
        } finally {
          setIsLoading(false);
        }
      };

      const sendBatchNativeAirdrop = async (recipientList) => {
        if (!web3 || !account) {
          setStatus(prev => `${prev}Wallet not connected. Please click "Connect Wallet".\n`);
          return;
        }

        if (!checkMetaMaskConnection()) {
          const reconnected = await reconnectMetaMask();
          if (!reconnected) {
            setStatus(prev => `${prev}Cannot proceed with airdrop. Please reconnect your wallet.\n`);
            return;
          }
        }

        if (!amount || isNaN(amount) || parseFloat(amount) <= 0) {
          setStatus(prev => `${prev}Invalid amount per address. Please enter a positive number (e.g., 0.1 CRO).\n`);
          return;
        }

        const validRecipients = recipientList.filter(addr => web3.utils.isAddress(addr));
        if (validRecipients.length === 0) {
          setStatus(prev => `${prev}No valid recipient addresses provided.\n`);
          return;
        }

        const batchSizeNum = parseInt(batchSize);
        if (isNaN(batchSizeNum) || batchSizeNum < 1 || batchSizeNum > 3) {
          setStatus(prev => `${prev}Invalid batch size. Please enter a number between 1 and 3.\n`);
          return;
        }

        if (validRecipients.length > batchSizeNum) {
          setStatus(prev => `${prev}Too many recipients (max ${batchSizeNum}). Please reduce the number of addresses or adjust the batch size.\n`);
          return;
        }

        setIsLoading(true);
        setStatus(prev => `${prev}Sending native airdrops to ${validRecipients.length} addresses (batch size: ${batchSizeNum})... Please confirm each transaction in MetaMask.\n`);

        try {
          const selectedNetwork = networks.find(n => n.name === network);
          const rpcUrl = customRpc || await getValidRpcUrl(selectedNetwork.rpcUrls);
          const web3Instance = new Web3(rpcUrl);
          setWeb3(web3Instance);
          let nonce = await web3Instance.eth.getTransactionCount(account);
          const amountWei = web3Instance.utils.toWei(amount, 'ether');
          let successCount = 0;

          for (const recipient of validRecipients) {
            if (!checkMetaMaskConnection()) {
              setStatus(prev => `${prev}MetaMask disconnected during airdrop. Please click "Reconnect Wallet" or reload the page.\n`);
              setIsLoading(false);
              return;
            }

            const tx = {
              from: account,
              to: recipient,
              value: amountWei,
              gas: 25000,
              gasPrice: await web3Instance.eth.getGasPrice(),
              nonce: nonce
            };

            try {
              const txHash = await window.ethereum.request({
                method: 'eth_sendTransaction',
                params: [tx]
              });
              setStatus(prev => `${prev}Success: Sent ${amount} ${selectedNetwork?.nativeCurrency || 'CRO'} to ${recipient}, Tx Hash: ${txHash}\n`);
              successCount++;
              nonce++;
              await new Promise(resolve => setTimeout(resolve, 3000));
            } catch (error) {
              setStatus(prev => `${prev}Error sending ${amount} ${selectedNetwork?.nativeCurrency || 'CRO'} to ${recipient}: ${error.message}${error.message.includes('Premature close') ? '. Try updating MetaMask or using a different RPC.' : ''}\n`);
            }
          }

          setStatus(prev => `${prev}Completed: Sent native airdrops to ${successCount} of ${validRecipients.length} addresses.\n`);
        } catch (error) {
          setStatus(prev => `${prev}Native airdrop failed: ${error.message}${error.message.includes('Premature close') ? '. Try updating MetaMask or using a different RPC.' : ''}\n`);
        } finally {
          setIsLoading(false);
        }
      };

      const sendBatchErc20Airdrop = async (recipientList) => {
        if (!web3 || !account) {
          setStatus(prev => `${prev}Wallet not connected. Please click "Connect Wallet".\n`);
          return;
        }

        if (!checkMetaMaskConnection()) {
          const reconnected = await reconnectMetaMask();
          if (!reconnected) {
            setStatus(prev => `${prev}Cannot proceed with airdrop. Please reconnect your wallet.\n`);
            return;
          }
        }

        if (!web3.utils.isAddress(tokenContract)) {
          setStatus(prev => `${prev}Invalid token contract address. Please enter a valid address (e.g., 0x...).\n`);
          return;
        }

        if (!amount || isNaN(amount) || parseFloat(amount) <= 0) {
          setStatus(prev => `${prev}Invalid amount per address. Please enter a positive number (e.g., 0.1).\n`);
          return;
        }

        const validRecipients = recipientList.filter(addr => web3.utils.isAddress(addr));
        if (validRecipients.length === 0) {
          setStatus(prev => `${prev}No valid recipient addresses provided.\n`);
          return;
        }

        const batchSizeNum = parseInt(batchSize);
        if (isNaN(batchSizeNum) || batchSizeNum < 1 || batchSizeNum > 3) {
          setStatus(prev => `${prev}Invalid batch size. Please enter a number between 1 and 3.\n`);
          return;
        }

        if (validRecipients.length > batchSizeNum) {
          setStatus(prev => `${prev}Too many recipients (max ${batchSizeNum}). Please reduce the number of addresses or adjust the batch size.\n`);
          return;
        }

        setIsLoading(true);
        setStatus(prev => `${prev}Sending ERC-20 airdrops to ${validRecipients.length} addresses (batch size: ${batchSizeNum})... Please confirm each transaction in MetaMask.\n`);

        try {
          const selectedNetwork = networks.find(n => n.name === network);
          const rpcUrl = customRpc || await getValidRpcUrl(selectedNetwork.rpcUrls);
          const web3Instance = new Web3(rpcUrl);
          setWeb3(web3Instance);
          const contract = new web3Instance.eth.Contract(erc20Abi, tokenContract);
          let nonce = await web3Instance.eth.getTransactionCount(account);
          const amountWei = web3Instance.utils.toWei(amount, 'ether');
          let successCount = 0;

          for (const recipient of validRecipients) {
            if (!checkMetaMaskConnection()) {
              setStatus(prev => `${prev}MetaMask disconnected during airdrop. Please click "Reconnect Wallet" or reload the page.\n`);
              setIsLoading(false);
              return;
            }

            const tx = {
              from: account,
              to: tokenContract,
              gas: 60000,
              gasPrice: await web3Instance.eth.getGasPrice(),
              nonce: nonce,
              data: contract.methods.transfer(recipient, amountWei).encodeABI()
            };

            try {
              const txHash = await window.ethereum.request({
                method: 'eth_sendTransaction',
                params: [tx]
              });
              setStatus(prev => `${prev}Success: Sent ${amount} tokens to ${recipient}, Tx Hash: ${txHash}\n`);
              successCount++;
              nonce++;
              await new Promise(resolve => setTimeout(resolve, 3000));
            } catch (error) {
              setStatus(prev => `${prev}Error sending ${amount} tokens to ${recipient}: ${error.message}${error.message.includes('Premature close') ? '. Try updating MetaMask or using a different RPC.' : ''}\n`);
            }
          }

          setStatus(prev => `${prev}Completed: Sent ERC-20 airdrops to ${successCount} of ${validRecipients.length} addresses.\n`);
        } catch (error) {
          setStatus(prev => `${prev}ERC-20 airdrop failed: ${error.message}${error.message.includes('Premature close') ? '. Try updating MetaMask or using a different RPC.' : ''}\n`);
        } finally {
          setIsLoading(false);
        }
      };

      const sendErc721Airdrop = async () => {
        if (!web3 || !account) {
          setStatus(prev => `${prev}Wallet not connected. Please click "Connect Wallet".\n`);
          return;
        }

        if (!checkMetaMaskConnection()) {
          const reconnected = await reconnectMetaMask();
          if (!reconnected) {
            setStatus(prev => `${prev}Cannot proceed with airdrop. Please reconnect your wallet.\n`);
            return;
          }
        }

        if (!web3.utils.isAddress(tokenContract)) {
          setStatus(prev => `${prev}Invalid NFT contract address. Please enter a valid address (e.g., 0x...).\n`);
          return;
        }

        const recipientList = recipients.split(',').map(addr => addr.trim()).filter(addr => addr);
        const tokenIdList = tokenIds.split(',').map(id => parseInt(id.trim())).filter(id => !isNaN(id));

        if (recipientList.length !== tokenIdList.length) {
          setStatus(prev => `${prev}Number of recipients and token IDs must match (e.g., 3 addresses and 3 token IDs).\n`);
          return;
        }

        const batchSizeNum = parseInt(batchSize);
        if (isNaN(batchSizeNum) || batchSizeNum < 1 || batchSizeNum > 3) {
          setStatus(prev => `${prev}Invalid batch size. Please enter a number between 1 and 3.\n`);
          return;
        }

        if (recipientList.length > batchSizeNum) {
          setStatus(prev => `${prev}Too many recipients (max ${batchSizeNum}). Please reduce the number of addresses or adjust the batch size.\n`);
          return;
        }

        setIsLoading(true);
        setStatus(prev => `${prev}Sending NFT airdrop to ${recipientList.length} addresses (batch size: ${batchSizeNum})... Please confirm transactions in MetaMask.\n`);

        try {
          const selectedNetwork = networks.find(n => n.name === network);
          const rpcUrl = customRpc || await getValidRpcUrl(selectedNetwork.rpcUrls);
          const web3Instance = new Web3(rpcUrl);
          setWeb3(web3Instance);
          const contract = new web3Instance.eth.Contract(erc721Abi, tokenContract);
          let nonce = await web3Instance.eth.getTransactionCount(account);
          let successCount = 0;

          for (let i = 0; i < recipientList.length; i++) {
            if (!checkMetaMaskConnection()) {
              setStatus(prev => `${prev}MetaMask disconnected during airdrop. Please click "Reconnect Wallet" or reload the page.\n`);
              setIsLoading(false);
              return;
            }

            const recipient = recipientList[i];
            const tokenId = tokenIdList[i];

            if (!web3.utils.isAddress(recipient)) {
              setStatus(prev => `${prev}Invalid address: ${recipient}. Skipping.\n`);
              continue;
            }

            const tx = {
              from: account,
              to: tokenContract,
              gas: 100000,
              gasPrice: await web3Instance.eth.getGasPrice(),
              nonce: nonce,
              data: contract.methods.transferFrom(account, recipient, tokenId).encodeABI()
            };

            try {
              const txHash = await window.ethereum.request({
                method: 'eth_sendTransaction',
                params: [tx]
              });
              setStatus(prev => `${prev}Success: Sent NFT ${tokenId} to ${recipient}, Tx Hash: ${txHash}\n`);
              successCount++;
              nonce++;
              await new Promise(resolve => setTimeout(resolve, 3000));
            } catch (error) {
              setStatus(prev => `${prev}Error sending NFT ${tokenId} to ${recipient}: ${error.message}${error.message.includes('Premature close') ? '. Try updating MetaMask or using a different RPC.' : ''}\n`);
            }
          }

          setStatus(prev => `${prev}Completed: Sent NFT airdrops to ${successCount} of ${recipientList.length} addresses.\n`);
        } catch (error) {
          setStatus(prev => `${prev}NFT airdrop failed: ${error.message}${error.message.includes('Premature close') ? '. Try updating MetaMask or using a different RPC.' : ''}\n`);
        } finally {
          setIsLoading(false);
        }
      };

      const sendBatchErc20Rewards = async () => {
        if (!web3 || !account) {
          setStatus(prev => `${prev}Wallet not connected. Please click "Connect Wallet".\n`);
          return;
        }

        if (!checkMetaMaskConnection()) {
          const reconnected = await reconnectMetaMask();
          if (!reconnected) {
            setStatus(prev => `${prev}Cannot proceed with reward distribution. Please reconnect your wallet.\n`);
            setIsLoading(false);
            return;
          }
        }

        if (!web3.utils.isAddress(rewardTokenContract)) {
          setStatus(prev => `${prev}Invalid reward token contract address. Please enter a valid address (e.g., 0x...).\n`);
          return;
        }

        if (nftHolders.length === 0) {
          setStatus(prev => `${prev}No NFT holders fetched. Please fetch holders first.\n`);
          return;
        }

        if (!rewardAmount || isNaN(rewardAmount) || parseFloat(rewardAmount) <= 0) {
          setStatus(prev => `${prev}Invalid reward amount. Please enter a positive number (e.g., 0.1).\n`);
          return;
        }

        const batchSizeNum = parseInt(batchSize);
        if (isNaN(batchSizeNum) || batchSizeNum < 1 || batchSizeNum > 3) {
          setStatus(prev => `${prev}Invalid batch size. Please enter a number between 1 and 3.\n`);
          return;
        }

        if (nftHolders.length > batchSizeNum) {
          setStatus(prev => `${prev}Too many NFT holders (max ${batchSizeNum}). Please fetch a smaller range of token IDs or adjust the batch size.\n`);
          return;
        }

        const confirm = window.confirm(`Are you sure you want to send ${rewardAmount} tokens to ${nftHolders.length} NFT holders? Confirm each transaction in MetaMask.`);
        if (!confirm) {
          setStatus(prev => `${prev}Reward distribution cancelled by user.\n`);
          return;
        }

        setIsLoading(true);
        setStatus(prev => `${prev}Sending ERC-20 rewards to ${nftHolders.length} NFT holders (batch size: ${batchSizeNum})... Please confirm each transaction in MetaMask.\n`);

        try {
          const selectedNetwork = networks.find(n => n.name === network);
          const rpcUrl = customRpc || await getValidRpcUrl(selectedNetwork.rpcUrls);
          const web3Instance = new Web3(rpcUrl);
          setWeb3(web3Instance);
          const contract = new web3Instance.eth.Contract(erc20Abi, rewardTokenContract);
          let nonce = await web3Instance.eth.getTransactionCount(account);
          const amountWei = web3Instance.utils.toWei(rewardAmount, 'ether');
          const validRecipients = nftHolders.map(h => h.owner).filter(addr => web3.utils.isAddress(addr));
          const amountPerHolder = (BigInt(amountWei) / BigInt(nftHolders.length)).toString();
          let successCount = 0;

          for (let i = 0; i < validRecipients.length; i++) {
            if (!checkMetaMaskConnection()) {
              const reconnected = await reconnectMetaMask();
              if (!reconnected) {
                setStatus(prev => `${prev}MetaMask disconnected during reward distribution. Please click "Reconnect Wallet" or reload the page.\n`);
                setIsLoading(false);
                return;
              }
            }

            const recipient = validRecipients[i];
            const amount = amountPerHolder;

            if (BigInt(amount) <= 0) {
              setStatus(prev => `${prev}Skipping ${recipient}: Invalid or zero amount.\n`);
              continue;
            }

            const tx = {
              from: account,
              to: rewardTokenContract,
              gas: 60000,
              gasPrice: await web3Instance.eth.getGasPrice(),
              nonce: nonce,
              data: contract.methods.transfer(recipient, amount).encodeABI()
            };

            try {
              const txHash = await window.ethereum.request({
                method: 'eth_sendTransaction',
                params: [tx]
              });
              setStatus(prev => `${prev}Success: Sent ${web3Instance.utils.fromWei(amount, 'ether')} tokens to ${recipient}, Tx Hash: ${txHash}\n`);
              successCount++;
              nonce++;
              await new Promise(resolve => setTimeout(resolve, 3000));
            } catch (error) {
              setStatus(prev => `${prev}Error sending ${web3Instance.utils.fromWei(amount, 'ether')} tokens to ${recipient}: ${error.message}${error.message.includes('Premature close') ? '. Try updating MetaMask or using a different RPC.' : error.message.includes('insufficient funds') ? '. Ensure your wallet has enough CRO for gas.' : ''}\n`);
            }
          }

          setStatus(prev => `${prev}Completed: Sent ERC-20 rewards to ${successCount} of ${validRecipients.length} NFT holders.\n`);
        } catch (error) {
          setStatus(prev => `${prev}ERC-20 reward distribution failed: ${error.message}${error.message.includes('Premature close') ? '. Try updating MetaMask or using a different RPC.' : error.message.includes('insufficient funds') ? '. Ensure your wallet has enough CRO for gas.' : ''}\n`);
        } finally {
          setIsLoading(false);
        }
      };

      const renderStatus = () => {
        const lines = status.split('\n');
        return lines.map((line, index) => {
          let className = 'text-gray-700 dark:text-gray-300';
          if (line.includes('Error') || line.includes('failed') || line.includes('disconnected')) {
            className = 'text-red-600 dark:text-red-400';
          } else if (line.includes('Success') || line.includes('Complete')) {
            className = 'text-green-600 dark:text-green-400';
          } else if (line.includes('Warning') || line.includes('Awaiting')) {
            className = 'text-yellow-600 dark:text-yellow-400';
          }
          return <p key={index} className={className}>{line}</p>;
        });
      };

      return (
        <div className="w-full max-w-3xl bg-white dark:bg-gray-800 rounded-xl shadow-xl p-6 transition-colors duration-300">
          <div className="flex justify-between items-center mb-6">
            <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Airdrop & Staking Rewards</h1>
            <button
              onClick={toggleTheme}
              className="p-2 rounded-full bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 transition"
              data-tooltip="Toggle Dark/Light Mode"
            >
              {theme === 'light' ? '🌙' : '☀️'}
            </button>
          </div>

          <div className="mb-6">
            <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-2">Wallet Connection</h2>
            <div className="flex items-center space-x-4">
              <button
                onClick={testConnection}
                disabled={isLoading}
                className={`px-4 py-2 rounded-lg text-white font-medium ${isLoading ? 'bg-gray-400 cursor-not-allowed' : 'bg-teal-600 hover:bg-teal-700'} transition`}
                data-tooltip="Test RPC and wallet connectivity"
              >
                Test Connection
              </button>
              <button
                onClick={connectWallet}
                disabled={isLoading}
                className={`px-4 py-2 rounded-lg text-white font-medium ${isLoading ? 'bg-gray-400 cursor-not-allowed' : 'bg-blue-600 hover:bg-blue-700'} transition`}
                data-tooltip="Connect via MetaMask"
              >
                {account ? `Connected: ${account.slice(0, 6)}...${account.slice(-4)}` : 'Connect Wallet'}
              </button>
              {account && (
                <>
                  <button
                    onClick={reconnectMetaMask}
                    disabled={isLoading}
                    className={`px-4 py-2 rounded-lg text-white font-medium ${isLoading ? 'bg-gray-400 cursor-not-allowed' : 'bg-yellow-600 hover:bg-yellow-700'} transition`}
                    data-tooltip="Reconnect MetaMask if disconnected"
                  >
                    Reconnect Wallet
                  </button>
                  <button
                    onClick={disconnectWallet}
                    className="px-4 py-2 rounded-lg bg-red-600 text-white hover:bg-red-700 transition"
                    data-tooltip="Disconnect your wallet"
                  >
                    Disconnect
                  </button>
                </>
              )}
            </div>
            <div className="mt-4">
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Network</label>
              <select
                value={network}
                onChange={(e) => switchNetwork(networks.find(n => n.name === e.target.value).chainId)}
                className="mt-1 block w-full rounded-lg border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white focus:ring-blue-500 focus:border-blue-500"
              >
                {networks.map(n => (
                  <option key={n.chainId} value={n.name}>{n.name}</option>
                ))}
              </select>
            </div>
            {network === 'Cronos Mainnet' && (
              <div className="mt-4">
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Custom Cronos RPC (Optional)</label>
                <input
                  type="text"
                  value={customRpc}
                  onChange={(e) => setCustomRpc(e.target.value)}
                  placeholder="e.g., https://cronos-rpc.publicnode.com"
                  className="mt-1 block w-full rounded-lg border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white focus:ring-blue-500 focus:border-blue-500"
                  data-tooltip="Enter a custom RPC URL for Cronos"
                />
              </div>
            )}
          </div>

          <div className="mb-6">
            <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-2">Fetch NFT Holders</h2>
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">NFT Contract Address</label>
                <input
                  type="text"
                  value={nftContract}
                  onChange={(e) => setNftContract(e.target.value)}
                  placeholder="0x..."
                  className="mt-1 block w-full rounded-lg border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white focus:ring-blue-500 focus:border-blue-500"
                  data-tooltip="Enter the ERC-721 contract address"
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Token ID Selection</label>
                <div className="flex items-center mt-1">
                  <input
                    type="checkbox"
                    checked={useSpecificIds}
                    onChange={() => setUseSpecificIds(!useSpecificIds)}
                    className="mr-2"
                  />
                  <span className="text-sm text-gray-700 dark:text-gray-300">Use Specific Token IDs</span>
                </div>
                {useSpecificIds ? (
                  <input
                    type="text"
                    value={specificTokenIds}
                    onChange={(e) => setSpecificTokenIds(e.target.value)}
                    placeholder="1,2,3"
                    className="mt-1 block w-full rounded-lg border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white focus:ring-blue-500 focus:border-blue-500"
                    data-tooltip="Enter comma-separated token IDs (max 5)"
                  />
                ) : (
                  <div className="flex space-x-2 mt-1">
                    <input
                      type="number"
                      value={startTokenId}
                      onChange={(e) => setStartTokenId(e.target.value)}
                      placeholder="Start ID"
                      min="1"
                      className="w-1/2 rounded-lg border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white focus:ring-blue-500 focus:border-blue-500"
                      data-tooltip="Start token ID (e.g., 1)"
                    />
                    <input
                      type="number"
                      value={endTokenId}
                      onChange={(e) => setEndTokenId(e.target.value)}
                      placeholder="End ID"
                      min="1"
                      className="w-1/2 rounded-lg border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white focus:ring-blue-500 focus:border-blue-500"
                      data-tooltip="End token ID (e.g., 5)"
                    />
                  </div>
                )}
              </div>
            </div>
            <button
              onClick={fetchNftHolders}
              disabled={isLoading}
              className={`mt-4 px-4 py-2 rounded-lg text-white font-medium ${isLoading ? 'bg-gray-400 cursor-not-allowed' : 'bg-green-600 hover:bg-green-700'} transition`}
              data-tooltip="Fetch NFT holders for the specified contract (max 5 token IDs)"
            >
              Fetch Holders
            </button>
            {nftHolders.length > 0 && (
              <div className="mt-4">
                <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300">NFT Holders ({nftHolders.length})</h3>
                <div className="scrollable-status mt-2 p-4 bg-gray-50 dark:bg-gray-700 rounded-lg">
                  {nftHolders.map((holder, index) => (
                    <p key={index} className="text-sm text-gray-700 dark:text-gray-300">
                      Token ID: {holder.tokenId}, Owner: {holder.owner.slice(0, 6)}...${holder.owner.slice(-4)}
                    </p>
                  ))}
                </div>
              </div>
            )}
          </div>

          <div className="mb-6">
            <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-2">Send Airdrop</h2>
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Token Type</label>
                <select
                  value={tokenType}
                  onChange={(e) => setTokenType(e.target.value)}
                  className="mt-1 block w-full rounded-lg border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white focus:ring-blue-500 focus:border-blue-500"
                >
                  <option value="native">Native (${networks.find(n => n.name === network)?.nativeCurrency || 'CRO'})</option>
                  <option value="erc20">ERC-20</option>
                  <option value="erc721">ERC-721</option>
                </select>
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Amount per Address</label>
                <input
                  type="text"
                  value={amount}
                  onChange={(e) => setAmount(e.target.value)}
                  placeholder={tokenType === 'erc721' ? 'Not applicable' : 'e.g., 0.1'}
                  disabled={tokenType === 'erc721'}
                  className="mt-1 block w-full rounded-lg border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white focus:ring-blue-500 focus:border-blue-500 disabled:bg-gray-200 dark:disabled:bg-gray-600"
                  data-tooltip="Amount to send per address (e.g., 0.1 CRO or tokens for native/ERC-20)"
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Recipient Addresses</label>
                <input
                  type="text"
                  value={recipients}
                  onChange={(e) => setRecipients(e.target.value)}
                  placeholder="0x...,0x..."
                  className="mt-1 block w-full rounded-lg border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white focus:ring-blue-500 focus:border-blue-500"
                  data-tooltip="Comma-separated recipient addresses (e.g., 0x123...,0x456...)"
                />
              </div>
              {tokenType !== 'native' && (
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Token Contract Address</label>
                  <input
                    type="text"
                    value={tokenContract}
                    onChange={(e) => setTokenContract(e.target.value)}
                    placeholder="0x..."
                    className="mt-1 block w-full rounded-lg border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white focus:ring-blue-500 focus:border-blue-500"
                    data-tooltip="Enter the ERC-20 or ERC-721 contract address"
                  />
                </div>
              )}
              {tokenType === 'erc721' && (
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Token IDs</label>
                  <input
                    type="text"
                    value={tokenIds}
                    onChange={(e) => setTokenIds(e.target.value)}
                    placeholder="1,2,3"
                    className="mt-1 block w-full rounded-lg border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white focus:ring-blue-500 focus:border-blue-500"
                    data-tooltip="Comma-separated token IDs to send (e.g., 1,2,3)"
                  />
                </div>
              )}
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Batch Size</label>
                <input
                  type="number"
                  value={batchSize}
                  onChange={(e) => {
                    const value = e.target.value;
                    if (value === '' || (parseInt(value) >= 1 && parseInt(value) <= 3)) {
                      setBatchSize(value);
                    }
                  }}
                  placeholder="1-3"
                  min="1"
                  max="3"
                  className="mt-1 block w-full rounded-lg border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white focus:ring-blue-500 focus:border-blue-500"
                  data-tooltip="Number of transactions per batch (1-3, default 2)"
                />
              </div>
            </div>
            <button
              onClick={() => {
                if (tokenType === 'native') {
                  sendBatchNativeAirdrop(recipients.split(',').map(addr => addr.trim()).filter(addr => addr));
                } else if (tokenType === 'erc20') {
                  sendBatchErc20Airdrop(recipients.split(',').map(addr => addr.trim()).filter(addr => addr));
                } else {
                  sendErc721Airdrop();
                }
              }}
              disabled={isLoading}
              className={`mt-4 px-4 py-2 rounded-lg text-white font-medium ${isLoading ? 'bg-gray-400 cursor-not-allowed' : 'bg-purple-600 hover:bg-purple-700'} transition`}
              data-tooltip="Send airdrop to specified recipients"
            >
              Send Airdrop
            </button>
          </div>

          <div className="mb-6">
            <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-2">Send Rewards to NFT Holders</h2>
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Reward Type</label>
                <select
                  value={rewardType}
                  onChange={(e) => setRewardType(e.target.value)}
                  className="mt-1 block w-full rounded-lg border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white focus:ring-blue-500 focus:border-blue-500"
                >
                  <option value="native">Native (${networks.find(n => n.name === network)?.nativeCurrency || 'CRO'})</option>
                  <option value="erc20">ERC-20</option>
                </select>
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Reward Amount</label>
                <input
                  type="text"
                  value={rewardAmount}
                  onChange={(e) => setRewardAmount(e.target.value)}
                  placeholder="e.g., 0.1"
                  className="mt-1 block w-full rounded-lg border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white focus:ring-blue-500 focus:border-blue-500"
                  data-tooltip="Total amount of tokens to distribute as rewards"
                />
              </div>
              {rewardType === 'erc20' && (
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Reward Token Contract</label>
                  <input
                    type="text"
                    value={rewardTokenContract}
                    onChange={(e) => setRewardTokenContract(e.target.value)}
                    placeholder="0x..."
                    className="mt-1 block w-full rounded-lg border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white focus:ring-blue-500 focus:border-blue-500"
                    data-tooltip="Enter the ERC-20 contract address for rewards"
                  />
                </div>
              )}
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Batch Size</label>
                <input
                  type="number"
                  value={batchSize}
                  onChange={(e) => {
                    const value = e.target.value;
                    if (value === '' || (parseInt(value) >= 1 && parseInt(value) <= 3)) {
                      setBatchSize(value);
                    }
                  }}
                  placeholder="1-3"
                  min="1"
                  max="3"
                  className="mt-1 block w-full rounded-lg border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white focus:ring-blue-500 focus:border-blue-500"
                  data-tooltip="Number of transactions per batch (1-3, default 2)"
                />
              </div>
            </div>
            <button
              onClick={() => {
                if (rewardType === 'native') {
                  sendBatchNativeRewards();
                } else {
                  sendBatchErc20Rewards();
                }
              }}
              disabled={isLoading}
              className={`mt-4 px-4 py-2 rounded-lg text-white font-medium ${isLoading ? 'bg-gray-400 cursor-not-allowed' : 'bg-purple-600 hover:bg-purple-700'} transition`}
              data-tooltip="Send rewards to fetched NFT holders"
            >
              Send Rewards
            </button>
          </div>

          <div className="mb-6">
            <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-2">Status Log</h2>
            <div className="scrollable-status p-4 bg-gray-50 dark:bg-gray-700 rounded-lg">
              {renderStatus()}
            </div>
          </div>
        </div>
      );
    };

    const root = createRoot(document.getElementById('root'));
    root.render(<AirdropStakingApp />);
  </script>
</body>
</html>