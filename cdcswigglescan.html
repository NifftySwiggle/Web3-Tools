<!DOCTYPE html>
<html lang="en" data-theme="modern">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Professional NFT Portfolio Explorer - Discover, Filter, and Download NFT Collections">
    <title>CDC SwiggleScan</title>

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/NifftySwiggle/Home/main/assets/NSlogo.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/NifftySwiggle/Home/main/assets/NSlogo.png" />
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="NFT Explorer Pro | Professional Portfolio Browser">
    <meta property="og:description" content="Discover, filter, and download NFT collections with our professional portfolio explorer">
    <meta property="og:type" content="website">
    
    <style>
        :root {
            /* Modern Color Palette */
            --primary-color: #6366f1;
            --primary-hover: #5b5fd1;
            --secondary-color: #10b981;
            --accent-color: #f59e0b;
            --error-color: #ef4444;
            --success-color: #22c55e;
            
            /* Neutral Colors */
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --surface-light: rgba(255, 255, 255, 0.05);
            --surface-medium: rgba(255, 255, 255, 0.1);
            --surface-dark: rgba(0, 0, 0, 0.2);
            
            /* Text Colors */
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            
            /* Spacing & Sizing */
            --border-radius: 12px;
            --border-radius-sm: 8px;
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.2);
            --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.3);
            --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.4);
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        [data-theme="light"] {
            --bg-primary: #ffffff;
            --bg-secondary: #f8fafc;
            --bg-tertiary: #e2e8f0;
            --surface-light: rgba(0, 0, 0, 0.02);
            --surface-medium: rgba(0, 0, 0, 0.05);
            --surface-dark: rgba(0, 0, 0, 0.1);
            --text-primary: #1e293b;
            --text-secondary: #475569;
            --text-muted: #64748b;
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1);
            --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
            min-height: 100vh;
        }

        /* Header Styles */
        .header {
            background: var(--bg-secondary);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--surface-medium);
            position: sticky;
            top: 0;
            z-index: 1000;
            padding: 1rem 0;
        }

        .header-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 2rem;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-color);
            text-decoration: none;
        }

        .logo-icon {
            width: 2.5rem;
            height: 2.5rem;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border-radius: var(--border-radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
        }

        .search-container {
            flex: 1;
            max-width: 500px;
            position: relative;
        }

        .search-input {
            width: 100%;
            padding: 0.875rem 1rem;
            background: var(--surface-light);
            border: 2px solid transparent;
            border-radius: var(--border-radius);
            color: var(--text-primary);
            font-size: 1rem;
            transition: var(--transition);
            outline: none;
        }

        .search-input:focus {
            border-color: var(--primary-color);
            background: var(--surface-medium);
            box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.1);
        }

        .search-input::placeholder {
            color: var(--text-muted);
        }

        .suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--surface-medium);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            max-height: 300px;
            overflow-y: auto;
            z-index: 1001;
            display: none;
            margin-top: 0.5rem;
        }

        .suggestion-item {
            padding: 0.75rem 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            cursor: pointer;
            transition: var(--transition);
            border-bottom: 1px solid var(--surface-light);
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-item:hover {
            background: var(--surface-light);
        }

        .suggestion-avatar {
            width: 2rem;
            height: 2rem;
            border-radius: 50%;
            object-fit: cover;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .theme-toggle {
            padding: 0.5rem;
            background: var(--surface-light);
            border: none;
            border-radius: var(--border-radius-sm);
            color: var(--text-primary);
            cursor: pointer;
            transition: var(--transition);
            width: 2.5rem;
            height: 2.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .theme-toggle:hover {
            background: var(--surface-medium);
            transform: scale(1.05);
        }

        /* Main Content */
        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        /* Profile Section */
        .profile-section {
            background: var(--bg-secondary);
            border-radius: var(--border-radius);
            padding: 2rem;
            margin-bottom: 2rem;
            display: none;
            box-shadow: var(--shadow-sm);
        }

        .profile-section.visible {
            display: block;
        }

        .profile-header {
            display: flex;
            align-items: center;
            gap: 2rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .profile-avatar {
            width: 120px;
            height: 120px;
            border-radius: var(--border-radius);
            object-fit: cover;
            box-shadow: var(--shadow-md);
        }

        .profile-info {
            flex: 1;
            min-width: 300px;
        }

        .profile-name {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .verified-badge {
            width: 1.5rem;
            height: 1.5rem;
            color: var(--success-color);
        }

        .profile-username {
            font-size: 1.25rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        .profile-stats {
            display: flex;
            gap: 2rem;
            flex-wrap: wrap;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-color);
        }

        .stat-label {
            font-size: 0.875rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Filters Section */
        .filters-section {
            background: var(--bg-secondary);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            margin-bottom: 2rem;
            display: none;
            box-shadow: var(--shadow-sm);
        }

        .filters-section.visible {
            display: block;
        }

        .filters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .filter-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .filter-select {
            padding: 0.75rem;
            background: var(--surface-light);
            border: 1px solid var(--surface-medium);
            border-radius: var(--border-radius-sm);
            color: var(--text-primary);
            font-size: 0.875rem;
            cursor: pointer;
            transition: var(--transition);
            outline: none;
        }

        .filter-select:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .filter-select option {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        /* Collection Title */
        .collection-title {
            text-align: center;
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 2rem;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            display: none;
        }

        .collection-title.visible {
            display: block;
        }

        /* NFT Grid */
        .nft-count {
            text-align: center;
            margin-bottom: 2rem;
            font-size: 1.125rem;
            color: var(--text-secondary);
        }

        .nft-count .count {
            font-weight: 700;
            color: var(--primary-color);
        }

        .nft-grid {
            display: grid;
            gap: 1rem;
            margin-bottom: 3rem;
        }

        .nft-grid.small {
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        }

        .nft-grid.medium {
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        }

        .nft-grid.large {
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        }

        .nft-card {
            position: relative;
            aspect-ratio: 1;
            background: var(--bg-secondary);
            border-radius: var(--border-radius);
            overflow: hidden;
            cursor: pointer;
            transition: var(--transition);
            box-shadow: var(--shadow-sm);
        }

        .nft-card:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-lg);
        }

        .nft-card img,
        .nft-card video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: var(--transition);
        }

        .nft-card:hover img,
        .nft-card:hover video {
            transform: scale(1.05);
        }

        .nft-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            color: white;
            padding: 1rem;
            transform: translateY(100%);
            transition: var(--transition);
        }

        .nft-card:hover .nft-overlay {
            transform: translateY(0);
        }

        .nft-title {
            font-weight: 600;
            font-size: 0.875rem;
            margin-bottom: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .nft-collection {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.8);
        }

        .nft-actions {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            display: flex;
            gap: 0.5rem;
            opacity: 0;
            transition: var(--transition);
        }

        .nft-card:hover .nft-actions {
            opacity: 1;
        }

        .nft-action-btn {
            width: 2rem;
            height: 2rem;
            background: rgba(0, 0, 0, 0.7);
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
        }

        .nft-action-btn:hover {
            background: var(--primary-color);
            transform: scale(1.1);
        }

        /* Download Buttons */
        .download-section {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 3rem;
            flex-wrap: wrap;
        }

        .download-btn {
            padding: 1rem 2rem;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            display: none;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            box-shadow: var(--shadow-sm);
        }

        .download-btn.visible {
            display: block;
        }

        .download-btn:hover {
            background: var(--primary-hover);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .download-btn.secondary {
            background: var(--secondary-color);
        }

        .download-btn.secondary:hover {
            background: #059669;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: var(--transition);
        }

        .modal.visible {
            display: flex;
            opacity: 1;
        }

        .modal-content {
            background: var(--bg-secondary);
            padding: 2rem;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            max-width: 500px;
            width: 90%;
            text-align: center;
            transform: scale(0.9);
            transition: var(--transition);
        }

        .modal.visible .modal-content {
            transform: scale(1);
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .progress-container {
            margin: 1.5rem 0;
        }

        .progress-bar {
            width: 100%;
            height: 0.5rem;
            background: var(--surface-medium);
            border-radius: 0.25rem;
            overflow: hidden;
            margin-bottom: 1rem;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            color: var(--text-secondary);
            font-weight: 500;
        }

        .modal-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 1.5rem;
        }

        .modal-btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: var(--border-radius-sm);
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
        }

        .modal-btn.primary {
            background: var(--primary-color);
            color: white;
        }

        .modal-btn.primary:hover {
            background: var(--primary-hover);
        }

        .modal-btn.secondary {
            background: var(--surface-light);
            color: var(--text-primary);
            border: 1px solid var(--surface-medium);
        }

        .modal-btn.secondary:hover {
            background: var(--surface-medium);
        }

        /* Error States */
        .error-message {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: var(--error-color);
            padding: 1rem;
            border-radius: var(--border-radius);
            margin-bottom: 1rem;
            text-align: center;
        }

        .no-results {
            text-align: center;
            padding: 3rem;
            color: var(--text-muted);
            font-size: 1.125rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .header-container {
                flex-direction: column;
                gap: 1rem;
            }

            .search-container {
                order: -1;
                max-width: none;
            }

            .main-container {
                padding: 1rem;
            }

            .profile-header {
                flex-direction: column;
                text-align: center;
            }

            .profile-stats {
                justify-content: center;
            }

            .filters-grid {
                grid-template-columns: 1fr;
            }

            .collection-title {
                font-size: 2rem;
            }

            .nft-grid.small {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            }

            .nft-grid.medium {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }

            .nft-grid.large {
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            }

            .download-section {
                flex-direction: column;
                align-items: center;
            }

            .download-btn {
                width: 100%;
                max-width: 300px;
            }
        }

        /* Loading Animation */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .loading {
            animation: pulse 2s infinite;
        }

        /* Scroll to top button */
        .scroll-top {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 3rem;
            height: 3rem;
            background: var(--primary-color);
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            transition: var(--transition);
            z-index: 1000;
            box-shadow: var(--shadow-md);
        }

        .scroll-top.visible {
            display: flex;
        }

        .scroll-top:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-container">
            <a href="#" class="logo">
                <div class="logo-icon"><img src="https://raw.githubusercontent.com/NifftySwiggle/Home/main/assets/NSlogo.png" alt="Logo" style="width: 100%; height: 100%; border-radius: var(--border-radius-sm);"></div>
                <span>SwiggleScan</span>
            </a>
            
            <div class="search-container">
                <input 
                    type="text" 
                    class="search-input" 
                    id="searchInput" 
                    placeholder="üîç Search for NFT profiles..."
                    autocomplete="off"
                >
                <div class="suggestions" id="suggestions"></div>
            </div>
            
            <div class="header-actions">
                <button class="theme-toggle" id="themeToggle" title="Toggle theme">
                    <span id="themeIcon">üåô</span>
                </button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main-container">
        <!-- Profile Section -->
        <section class="profile-section" id="profileSection">
            <div class="profile-header">
                <img class="profile-avatar" id="profileAvatar" src="" alt="Profile Avatar">
                <div class="profile-info">
                    <h1 class="profile-name" id="profileName">
                        <span id="displayName"></span>
                        <svg class="verified-badge" id="verifiedBadge" style="display: none;" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                        </svg>
                    </h1>
                    <p class="profile-username" id="profileUsername"></p>
                    <div class="profile-stats">
                        <div class="stat-item">
                            <div class="stat-value" id="totalNFTs">0</div>
                            <div class="stat-label">Total NFTs</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="totalCollections">0</div>
                            <div class="stat-label">Collections</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="totalCreators">0</div>
                            <div class="stat-label">Artists</div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Filters Section -->
        <section class="filters-section" id="filtersSection">
            <div class="filters-grid">
                <div class="filter-group">
                    <label class="filter-label">Artists</label>
                    <select class="filter-select" id="creatorFilter">
                        <option value="">All Artists</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label class="filter-label">Collections</label>
                    <select class="filter-select" id="collectionFilter">
                        <option value="">All Collections</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label class="filter-label">Blockchain</label>
                    <select class="filter-select" id="chainFilter">
                        <option value="">All Chains</option>
                        <option value="CRONOS">Cronos</option>
                        <option value="CRONOS_POS">Cronos POS</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label class="filter-label">Status</label>
                    <select class="filter-select" id="statusFilter">
                        <option value="">All Status</option>
                        <option value="curated">Curated</option>
                        <option value="regular">Regular</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label class="filter-label">Grid Size</label>
                    <select class="filter-select" id="gridSizeFilter">
                        <option value="small">Small</option>
                        <option value="medium">Medium</option>
                        <option value="large">Large</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label class="filter-label">Sort By</label>
                    <select class="filter-select" id="sortFilter">
                        <option value="newest">Newest First</option>
                        <option value="oldest">Oldest First</option>
                        <option value="rank">By Rarity</option>
                    </select>
                </div>
            </div>
        </section>

        <!-- Collection Title -->
        <h2 class="collection-title" id="collectionTitle"></h2>

        <!-- Error Message -->
        <div class="error-message" id="errorMessage" style="display: none;"></div>

        <!-- NFT Count -->
        <div class="nft-count" id="nftCount"></div>

        <!-- NFT Grid -->
        <div class="nft-grid small" id="nftGrid"></div>

        <!-- No Results -->
        <div class="no-results" id="noResults" style="display: none;">
            <p>No NFTs found matching your criteria.</p>
            <p>Try adjusting your filters or search for a different profile.</p>
        </div>

        <!-- Download Buttons -->
        <div class="download-section">
            <button class="download-btn" id="downloadAssetsBtn">
                üì¶ Download All Assets
            </button>
            <button class="download-btn secondary" id="downloadCollageBtn">
                üñºÔ∏è Create Collage
            </button>
        </div>
    </main>

    <!-- Progress Modal -->
    <div class="modal" id="progressModal">
        <div class="modal-content">
            <h3 class="modal-title" id="modalTitle">Processing...</h3>
            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">Initializing...</div>
            </div>
            <div class="modal-actions">
                <button class="modal-btn secondary" id="cancelBtn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Scroll to Top Button -->
    <button class="scroll-top" id="scrollTop">‚Üë</button>

    <script>
        // Application State
        const state = {
            allNFTs: [],
            filteredNFTs: [],
            currentProfile: null,
            isLoading: false,
            searchTimeout: null,
            abortController: null,
            isDownloadCancelled: false,
            activeSearch: null
        };

        // Constants
        const GRAPHQL_ENDPOINT = "https://crypto.com/nft-api/graphql";
        const CACHE = new Map();
        
       
        const profileQuery = `
            query User($id: ID!, $cacheId: ID) {
                public(cacheId: $cacheId) {
                    user(id: $id) {
                        username
                        displayName
                        verified
                        avatar {
                            url
                        }
                        twitterUsername
                        facebookUsername
                        instagramUsername
                    }
                }
            }
        `;

        const nftQuery = `
            query GetProfileAssets($ownerId: ID!, $first: Int!, $skip: Int!) {
                public {
                    profileAssets(ownerId: $ownerId, first: $first, skip: $skip) {
                        id
                        name
                        cover {
                            url
                        }
                        collection {
                            id
                            name
                            creator {
                                id
                                displayName
                            }
                        }
                        isExternalNft
                        externalNftMetadata {
                            network
                        }
                        defaultListingV2 {
                            salePriceDecimalUSD
                        }
                        latestPurchasedEdition {
                            priceUSD
                        }
                        createdAt
                        defaultRarityRank
                        isCurated
                    }
                }
            }
        `;

        // DOM Elements
        const elements = {
            searchInput: document.getElementById('searchInput'),
            suggestions: document.getElementById('suggestions'),
            themeToggle: document.getElementById('themeToggle'),
            themeIcon: document.getElementById('themeIcon'),
            profileSection: document.getElementById('profileSection'),
            profileAvatar: document.getElementById('profileAvatar'),
            profileName: document.getElementById('profileName'),
            displayName: document.getElementById('displayName'),
            profileUsername: document.getElementById('profileUsername'),
            verifiedBadge: document.getElementById('verifiedBadge'),
            totalNFTs: document.getElementById('totalNFTs'),
            totalCollections: document.getElementById('totalCollections'),
            totalCreators: document.getElementById('totalCreators'),
            filtersSection: document.getElementById('filtersSection'),
            creatorFilter: document.getElementById('creatorFilter'),
            collectionFilter: document.getElementById('collectionFilter'),
            chainFilter: document.getElementById('chainFilter'),
            statusFilter: document.getElementById('statusFilter'),
            gridSizeFilter: document.getElementById('gridSizeFilter'),
            sortFilter: document.getElementById('sortFilter'),
            collectionTitle: document.getElementById('collectionTitle'),
            errorMessage: document.getElementById('errorMessage'),
            nftCount: document.getElementById('nftCount'),
            nftGrid: document.getElementById('nftGrid'),
            noResults: document.getElementById('noResults'),
            downloadAssetsBtn: document.getElementById('downloadAssetsBtn'),
            downloadCollageBtn: document.getElementById('downloadCollageBtn'),
            progressModal: document.getElementById('progressModal'),
            modalTitle: document.getElementById('modalTitle'),
            progressFill: document.getElementById('progressFill'),
            progressText: document.getElementById('progressText'),
            cancelBtn: document.getElementById('cancelBtn'),
            scrollTop: document.getElementById('scrollTop')
        };

        // Utility Functions
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        function sanitizeInput(input) {
            return input.replace(/[<>]/g, '').trim().toLowerCase();
        }

        function sanitizeFileName(name, index = 0) {
            if (!name || name.trim() === '') {
                return `nft_${index}`;
            }
            return name.replace(/[/\\:*?"<>|]/g, '').trim().substring(0, 100) || `nft_${index}`;
        }

        function showError(message) {
            elements.errorMessage.textContent = message;
            elements.errorMessage.style.display = 'block';
            setTimeout(() => {
                elements.errorMessage.style.display = 'none';
            }, 5000);
        }

        function showModal(title, text) {
            elements.modalTitle.textContent = title;
            elements.progressText.textContent = text;
            elements.progressFill.style.width = '0%';
            elements.progressModal.classList.add('visible');
        }

        function hideModal() {
            elements.progressModal.classList.remove('visible');
        }

        function updateProgress(percentage, text) {
            elements.progressFill.style.width = `${percentage}%`;
            elements.progressText.textContent = text;
        }

        // API Functions
        async function fetchWithCache(key, fetchFn, retries = 3, delay = 1000) {
            if (key.startsWith('image_')) {
                // Ignore cache for image URLs
                return await fetchFn();
            }
            if (CACHE.has(key)) {
                console.log(`Cache hit for ${key}`);
                return CACHE.get(key);
            }
            for (let i = 0; i < retries; i++) {
                try {
                    const data = await fetchFn();
                    CACHE.set(key, data);
                    console.log(`Cache set for ${key}`);
                    return data;
                } catch (error) {
                    console.error(`Attempt ${i + 1} failed for ${key}:`, error.message);
                    if (i < retries - 1) {
                        console.log(`Retrying in ${delay}ms...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 1.5; // Exponential backoff
                    } else {
                        throw error;
                    }
                }
            }
        }

        async function searchProfiles(query) {
            if (!query || query.length < 3) {
                elements.suggestions.style.display = 'none';
                console.log('Query too short, clearing suggestions');
                return;
            }

            elements.suggestions.innerHTML = '<div class="suggestion-item">Searching...</div>';
            elements.suggestions.style.display = 'block';

            if (state.abortController) {
                state.abortController.abort();
            }

            const searchToken = { cancel: false };
            state.abortController = searchToken;

            try {
                const profileData = await fetchWithCache(`profile_${query}`, async (signal) => {
                    const response = await fetch(GRAPHQL_ENDPOINT, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            query: profileQuery,
                            variables: { id: query, cacheId: "nft-portal" }
                        }),
                        signal
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const result = await response.json();
                    return result.data?.public?.user;
                });

                if (searchToken.cancel) {
                    return;
                }

                elements.suggestions.innerHTML = '';
                if (profileData && profileData.username) {
                    const suggestionItem = document.createElement('div');
                    suggestionItem.className = 'suggestion-item';
                    suggestionItem.innerHTML = `
                        ${profileData.avatar?.url ? `<img src="${profileData.avatar.url}" alt="Avatar" class="suggestion-avatar">` : ''}
                        <div>
                            <div>${profileData.displayName || profileData.username}</div>
                            <div style="font-size: 0.8rem; opacity: 0.7;">@${profileData.username}</div>
                        </div>
                    `;
                    suggestionItem.addEventListener('click', () => {
                        selectProfile(profileData);
                    });
                    elements.suggestions.appendChild(suggestionItem);
                    elements.suggestions.style.display = 'block';
                } else {
                    elements.suggestions.innerHTML = '<div class="suggestion-item">No profiles found</div>';
                    elements.suggestions.style.display = 'block';
                }
            } catch (error) {
                if (error.message !== 'Search cancelled') {
                    console.error('Search error:', error);
                    elements.suggestions.innerHTML = '<div class="suggestion-item">Search failed</div>';
                    elements.suggestions.style.display = 'block';
                    setTimeout(() => {
                        elements.suggestions.style.display = 'none';
                    }, 2000);
                }
            } finally {
                if (state.abortController === searchToken) {
                    state.abortController = null;
                }
            }
        }

        async function fetchAllNFTs(ownerId, progressCallback) {
            const first = 60;
            let skip = 0;
            let allAssets = [];
            let hasMore = true;

            console.log('Starting fetchAllNFTs for:', ownerId);

            while (hasMore) {
                const nftVariables = { ownerId, first, skip };
                try {
                    const response = await fetch(GRAPHQL_ENDPOINT, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ query: nftQuery, variables: nftVariables })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
                    }

                    const result = await response.json();
                    console.log('GraphQL Response:', result);
                    
                    if (result.errors) {
                        throw new Error(`GraphQL Error: ${result.errors.map(e => e.message).join(', ')}`);
                    }

                    const assets = result.data?.public?.profileAssets || [];
                    assets.forEach((asset, index) => {
                        console.log(`Asset ${skip + index + 1}:`, {
                            id: asset.id,
                            name: asset.name || 'No name',
                            collectionName: asset.collection?.name || 'No collection name',
                            collectionId: asset.collection?.id || 'No collection ID',
                            creatorId: asset.collection?.creator?.id || 'No creator ID',
                            creatorDisplayName: asset.collection?.creator?.displayName || 'No creator displayName',
                            isCurated: asset.isCurated,
                            isExternalNft: asset.isExternalNft,
                            network: asset.externalNftMetadata?.network || 'No network'
                        });
                    });
                    allAssets = [...allAssets, ...assets];
                    skip += first;
                    hasMore = assets.length === first;

                    if (progressCallback) {
                        progressCallback(allAssets.length);
                    }
                } catch (error) {
                    console.error(`Failed to fetch NFTs: ${error.message}`);
                    throw error;
                }
            }

            console.log('All NFTs fetched:', {
                total: allAssets.length,
                hasCollections: allAssets.some(asset => asset.collection?.name),
                hasCreators: allAssets.some(asset => asset.collection?.creator?.id),
                collectionNames: allAssets
                    .filter(asset => asset.collection?.name)
                    .map(asset => asset.collection.name)
                    .filter((name, index, self) => self.indexOf(name) === index)
            });

            return allAssets;
        }

        // Profile Functions
        async function selectProfile(profile) {
            elements.searchInput.value = profile.username;
            elements.suggestions.style.display = 'none';
            await loadProfile(profile);
        }

        async function loadProfile(profile) {
            if (state.isLoading) return;
            
            state.isLoading = true;
            state.currentProfile = profile;
            
            // Clear previous data
            state.allNFTs = [];
            state.filteredNFTs = [];
            
            try {
                showModal('Loading Profile', `Loading profile for ${profile.username}...`);
                
                // First, get the full profile data
                console.log('Fetching profile data for:', profile.username);
                const profileData = await fetchWithCache(`profile_${profile.username}`, async (signal) => {
                    const response = await fetch(GRAPHQL_ENDPOINT, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            query: profileQuery,
                            variables: { id: profile.username, cacheId: "nft-portal" }
                        }),
                        signal
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const result = await response.json();
                    console.log('Profile API response:', result);
                    return result.data?.public?.user;
                });

                if (!profileData) {
                    throw new Error(`Profile not found for user: ${profile.username}`);
                }

                console.log('Profile data retrieved:', profileData);

                // Update profile UI
                updateProfileUI(profileData);
                state.currentProfile = profileData; // Update with full profile data
                
                updateProgress(20, `0 assets`);
                // Fetch NFTs with progress tracking - Don't use cache for NFTs to ensure fresh data
                console.log('Starting NFT fetch...');
                state.allNFTs = await fetchAllNFTs(profileData.username, (nftCount) => {
                    console.log(`Progress callback: ${nftCount} assets loaded`);
                    updateProgress(Math.min(20 + (nftCount / 1000) * 70, 90), `${nftCount} assets`);
                });

                console.log('NFT fetch completed. Total NFTs:', state.allNFTs.length);
                updateProgress(100, `${state.allNFTs.length} assets loaded successfully!`);
                
                if (state.allNFTs.length > 0) {
                    console.log('Processing NFTs and updating UI...');
                    // Update stats and filters
                    updateStats();
                    updateFilters();
                    filterNFTs();
                    
                    // Show sections
                    elements.profileSection.classList.add('visible');
                    elements.filtersSection.classList.add('visible');
                } else {
                    console.log('No NFTs found for this profile');
                    elements.profileSection.classList.add('visible');
                    elements.noResults.style.display = 'block';
                    elements.noResults.innerHTML = '<p>This profile has no NFTs.</p>';
                    elements.downloadAssetsBtn.classList.remove('visible');
                    elements.downloadCollageBtn.classList.remove('visible');
                }
                
                setTimeout(hideModal, 500);
                
            } catch (error) {
                console.error('Error loading profile:', error);
                showError(`Failed to load profile: ${error.message}`);
                hideModal();
            } finally {
                state.isLoading = false;
            }
        }

        function updateProfileUI(profile) {
            elements.displayName.textContent = profile.displayName || profile.username;
            elements.profileUsername.textContent = `@${profile.username}`;
            elements.profileAvatar.src = profile.avatar?.url || '';
            elements.verifiedBadge.style.display = profile.verified ? 'block' : 'none';
        }

        function updateStats() {
            const collections = new Set(state.allNFTs.map(nft => nft.collection?.id).filter(Boolean));
            const creators = new Set(state.allNFTs.map(nft => nft.collection?.creator?.id).filter(Boolean));
            
            elements.totalNFTs.textContent = state.allNFTs.length.toLocaleString();
            elements.totalCollections.textContent = collections.size.toLocaleString();
            elements.totalCreators.textContent = creators.size.toLocaleString();
        }

        function updateFilters() {
            console.log('Updating filters with', state.allNFTs.length, 'NFTs');
            
            populateCreatorFilter(state.allNFTs);
            
            populateCollectionFilter(state.allNFTs);
        }

        function populateCreatorFilter(nfts) {
            if (!elements.creatorFilter) {
                console.error('Creator filter element not found');
                return;
            }

            // Create object to store NFT counts by creator
            const creatorCounts = {};
            nfts.forEach(nft => {
                const creatorId = nft.collection?.creator?.id;
                const creatorDisplayName = nft.collection?.creator?.displayName || creatorId || 'Unknown';
                if (creatorId) {
                    if (!creatorCounts[creatorId]) {
                        creatorCounts[creatorId] = {
                            displayName: creatorDisplayName,
                            count: 0
                        };
                    }
                    creatorCounts[creatorId].count++;
                }
            });

            // Sort creators by NFT count (descending), then by displayName
            const sortedCreators = Object.keys(creatorCounts).sort((a, b) => {
                const countDiff = creatorCounts[b].count - creatorCounts[a].count;
                if (countDiff !== 0) return countDiff;
                return creatorCounts[a].displayName.localeCompare(creatorCounts[b].displayName);
            });

            // Check for duplicate displayNames
            const displayNameCounts = {};
            sortedCreators.forEach(creatorId => {
                const displayName = creatorCounts[creatorId].displayName;
                displayNameCounts[displayName] = (displayNameCounts[displayName] || 0) + 1;
            });

            // Determine if device is mobile
            const isMobile = window.innerWidth <= 768;

            // Populate dropdown
            elements.creatorFilter.innerHTML = '<option value="">ALL ARTISTS</option>';
            sortedCreators.forEach(creatorId => {
                const option = document.createElement('option');
                option.value = creatorId;
                const displayName = creatorCounts[creatorId].displayName;
                const count = creatorCounts[creatorId].count;
                // Apply uppercase for mobile, otherwise keep original text
                const displayText = isMobile ? displayName.toUpperCase() : displayName;
                option.textContent = displayNameCounts[displayName] > 1
                    ? `${displayText} (${creatorId}) (${count})`
                    : `${displayText} (${count})`;
                elements.creatorFilter.appendChild(option);
            });

            console.log('Creator filter populated with:', sortedCreators.map(id => ({
                id,
                displayName: creatorCounts[id].displayName,
                count: creatorCounts[id].count
            })));
        }

        function populateCollectionFilter(nfts) {
            if (!elements.collectionFilter || !elements.creatorFilter) {
                console.error('Collection or creator filter element not found');
                return;
            }

            const selectedCreator = elements.creatorFilter.value;
            const collectionCounts = {};

            nfts.forEach((nft, index) => {
                const collectionName = nft.collection?.name || 'Unknown Collection';
                const creatorId = nft.collection?.creator?.id;
                if (!creatorId) {
                    console.log(`NFT at index ${index} has no creator ID:`, {
                        id: nft.id,
                        name: nft.name,
                        collection: nft.collection
                    });
                }
                if (!selectedCreator || creatorId === selectedCreator) {
                    collectionCounts[collectionName] = (collectionCounts[collectionName] || 0) + 1;
                }
            });

            const sortedCollections = Object.keys(collectionCounts).sort((a, b) => {
                const countDiff = collectionCounts[b] - collectionCounts[a];
                return countDiff !== 0 ? countDiff : a.localeCompare(b);
            });

            const currentValue = elements.collectionFilter.value;
            // Determine if device is mobile
            const isMobile = window.innerWidth <= 768;
            elements.collectionFilter.innerHTML = '<option value="">ALL COLLECTIONS</option>';
            sortedCollections.forEach(collection => {
                const option = document.createElement('option');
                option.value = collection;
                // Apply uppercase for mobile, otherwise keep original text
                const displayText = isMobile ? collection.toUpperCase() : collection;
                option.textContent = `${displayText} (${collectionCounts[collection]})`;
                elements.collectionFilter.appendChild(option);
            });

            // Restore current value if it still exists
            if (currentValue && sortedCollections.includes(currentValue)) {
                elements.collectionFilter.value = currentValue;
            } else {
                elements.collectionFilter.value = '';
            }

            // Enable filter if NFTs exist
            elements.collectionFilter.disabled = nfts.length === 0;
            console.log('Collection filter populated:', {
                selectedCreator,
                totalNFTs: nfts.length,
                collections: sortedCollections,
                collectionCounts,
                selectedValue: elements.collectionFilter.value,
                disabled: elements.collectionFilter.disabled
            });
        }

        // Filter and Display Functions
        function filterNFTs() {
            console.log('Filtering NFTs with', state.allNFTs.length, 'assets', {
                creator: elements.creatorFilter.value,
                collection: elements.collectionFilter.value,
                chain: elements.chainFilter.value,
                status: elements.statusFilter.value
            });

            if (!state.allNFTs || !state.allNFTs.length) {
                displayNFTs([]);
                elements.collectionTitle.textContent = '';
                elements.collectionTitle.classList.remove('visible');
                elements.collectionFilter.disabled = true;
                elements.creatorFilter.disabled = true;
                console.log('No NFTs to filter, collection and creator filters disabled');
                return;
            }

            let filteredNFTs = [...state.allNFTs];

            // Apply creator filter
            const creatorValue = elements.creatorFilter.value;
            if (creatorValue) {
                filteredNFTs = filteredNFTs.filter(nft => nft.collection?.creator?.id === creatorValue);
                console.log('After creator filter:', filteredNFTs.length, 'NFTs');
            }

            // Apply collection filter
            const collectionValue = elements.collectionFilter.value;
            if (collectionValue) {
                filteredNFTs = filteredNFTs.filter(nft => (nft.collection?.name || 'Unknown Collection') === collectionValue);
                console.log('After collection filter:', filteredNFTs.length, 'NFTs');
            }

            // Populate the collection filter based on the current creator filter
            populateCollectionFilter(creatorValue ? state.allNFTs.filter(nft => nft.collection?.creator?.id === creatorValue) : state.allNFTs);

            // Update chain and status filters based on the filtered NFTs
            let allCurated = true, allNonCurated = true, allCronos = true, allCronosPos = true;
            filteredNFTs.forEach(nft => {
                const isCurated = nft.isCurated !== undefined ? nft.isCurated : false;
                const isExternalNft = nft.isExternalNft;
                const network = nft.externalNftMetadata?.network?.toUpperCase() || '';
                if (!isCurated) allCurated = false;
                if (isCurated) allNonCurated = false;
                if (isExternalNft !== true || network !== 'CRONOS') allCronos = false;
                if (isExternalNft !== false) allCronosPos = false;
            });

            elements.statusFilter.value = allCurated ? 'curated' : allNonCurated ? 'regular' : '';
            elements.statusFilter.disabled = allCurated || allNonCurated;
            elements.chainFilter.value = allCronos ? 'CRONOS' : allCronosPos ? 'CRONOS_POS' : '';
            elements.chainFilter.disabled = allCronos || allCronosPos;

            // Ensure filters are enabled if any NFTs exist
            const hasCollections = state.allNFTs.some(nft => nft.collection?.name || nft.collection);
            const hasCreators = state.allNFTs.some(nft => nft.collection?.creator?.id);
            elements.collectionFilter.disabled = !hasCollections;
            elements.creatorFilter.disabled = !hasCreators;
            console.log('Filter states:', {
                collectionDisabled: elements.collectionFilter.disabled,
                creatorDisabled: elements.creatorFilter.disabled,
                hasCollections,
                hasCreators,
                chainDisabled: elements.chainFilter.disabled,
                statusDisabled: elements.statusFilter.disabled
            });

            // Apply chain filter
            if (elements.chainFilter.value) {
                filteredNFTs = filteredNFTs.filter(nft => {
                    const isExternalNft = nft.isExternalNft;
                    const network = nft.externalNftMetadata?.network?.toUpperCase() || '';
                    if (elements.chainFilter.value === 'CRONOS') {
                        return isExternalNft === true && network === 'CRONOS';
                    }
                    if (elements.chainFilter.value === 'CRONOS_POS') {
                        return isExternalNft === false;
                    }
                    return true;
                });
                console.log('After chain filter:', filteredNFTs.length, 'NFTs');
            }

            // Apply status filter
            if (elements.statusFilter.value) {
                filteredNFTs = filteredNFTs.filter(nft => {
                    const isCurated = nft.isCurated !== undefined ? nft.isCurated : false;
                    return elements.statusFilter.value === 'curated' ? isCurated : elements.statusFilter.value === 'regular' ? !isCurated : true;
                });
                console.log('After status filter:', filteredNFTs.length, 'NFTs');
            }

            // Sort NFTs
            const sortValue = elements.sortFilter.value || 'newest';
            filteredNFTs.sort((a, b) => {
                if (sortValue === 'rank') {
                    return (a.defaultRarityRank || Infinity) - (b.defaultRarityRank || Infinity);
                } else if (sortValue === 'oldest') {
                    return new Date(a.createdAt) - new Date(b.createdAt);
                }
                return new Date(b.createdAt) - new Date(a.createdAt);
            });

            // Update collection title
            let titleText = '';
            let creatorDisplayName = '';
            if (creatorValue) {
                const creatorOption = elements.creatorFilter.querySelector(`option[value="${creatorValue}"]`);
                if (creatorOption) {
                    creatorDisplayName = creatorOption.textContent.replace(/\s*\(\d+\)$/, '');
                }
            }

            // Build title with span tags for styling
            if (creatorValue && creatorDisplayName) {
                titleText = `${creatorDisplayName.toUpperCase()} / ${collectionValue ? collectionValue.toUpperCase() : 'ALL COLLECTIONS'}`;
            } else {
                titleText = collectionValue ? collectionValue.toUpperCase() : 'ALL COLLECTIONS';
            }

            if (titleText && titleText !== 'ALL COLLECTIONS') {
                elements.collectionTitle.textContent = titleText;
                elements.collectionTitle.classList.add('visible');
            } else {
                elements.collectionTitle.classList.remove('visible');
            }

            console.log('Final filtered NFTs:', filteredNFTs.length, 'for creator:', elements.creatorFilter.value || 'All', 'collection:', collectionValue || 'All');
            
            state.filteredNFTs = filteredNFTs;
            displayNFTs();
        }

        function displayNFTs(assets) {
            const assetsToDisplay = assets || state.filteredNFTs || [];
            const gridSize = elements.gridSizeFilter.value;
            elements.nftGrid.className = `nft-grid ${gridSize}`;
            
            console.log(`displayNFTs called with ${assetsToDisplay.length} assets`);

            if (assetsToDisplay.length === 0) {
                elements.nftGrid.innerHTML = '';
                elements.nftCount.innerHTML = '';
                elements.noResults.style.display = 'block';
                elements.downloadAssetsBtn.classList.remove('visible');
                elements.downloadCollageBtn.classList.remove('visible');
                return;
            }

            elements.noResults.style.display = 'none';
            
            const seenIds = new Set();
            const uniqueAssets = assetsToDisplay.filter((asset, index) => {
                const key = asset.id || `index-${index}`;
                if (seenIds.has(key)) {
                    console.log(`Duplicate asset filtered out: ${asset.name || asset.id} (${key})`);
                    return false;
                }
                seenIds.add(key);
                return true;
            });

            console.log('Unique assets after deduplication:', uniqueAssets.length);
            
            // Update count
            const profile = state.currentProfile;
            const selectedCollection = elements.collectionFilter.value;
            elements.nftCount.innerHTML = selectedCollection
                ? `<span style="color: var(--primary-color);">${profile.username.toUpperCase()}</span> has <span class="count">${uniqueAssets.length}</span> assets in this collection.`
                : `<span style="color: var(--primary-color);">${profile.username.toUpperCase()}</span> has <span class="count">${uniqueAssets.length}</span> assets.`;

            // Show download buttons
            elements.downloadAssetsBtn.classList.add('visible');
            elements.downloadCollageBtn.classList.add('visible');
            elements.downloadAssetsBtn.textContent = `üì¶ Download ${uniqueAssets.length} Assets`;

            // Create NFT cards
            elements.nftGrid.innerHTML = '';
            uniqueAssets.forEach((nft, index) => {
                const card = createNFTCard(nft, index);
                elements.nftGrid.appendChild(card);
            });

            console.log('NFT grid populated with', uniqueAssets.length, 'cards');
        }

        function createNFTCard(nft, index) {
            const card = document.createElement('div');
            card.className = 'nft-card';
            
            const imageUrl = nft.cover?.url || '';
            const title = nft.name || `NFT #${nft.id || index + 1}`;
            const collection = nft.collection?.name || 'Unknown Collection';
            
            const mediaElement = imageUrl.endsWith('.mp4') ? 'video' : 'img';
            const mediaProps = mediaElement === 'video' ? 'muted loop playsinline' : '';
            
            card.innerHTML = `
                <${mediaElement} src="${imageUrl}" alt="${title}" ${mediaProps} loading="lazy">
                <div class="nft-overlay">
                    <div class="nft-title">${title}</div>
                    <div class="nft-collection">${collection}</div>
                </div>
                <div class="nft-actions">
                    <button class="nft-action-btn" onclick="downloadSingleNFT('${imageUrl}', '${title}', ${index})" title="Download">
                        üì•
                    </button>
                    ${nft.id ? `<button class="nft-action-btn" onclick="openNFTPage('${nft.id}')" title="View on Crypto.com">üîó</button>` : ''}
                </div>
            `;

            // Add hover effect for videos
            if (mediaElement === 'video') {
                const video = card.querySelector('video');
                card.addEventListener('mouseenter', () => video.play());
                card.addEventListener('mouseleave', () => video.pause());
            }

            return card;
        }

        function updateCollectionTitle() {
            const creatorName = elements.creatorFilter.selectedOptions[0]?.textContent;
            const collectionName = elements.collectionFilter.value;
            
            let title = '';
            if (creatorName && creatorName !== 'All Artists') {
                title = `${creatorName}`;
                if (collectionName) {
                    title += ` / ${collectionName}`;
                }
            } else if (collectionName) {
                title = collectionName;
            }
            
            if (title) {
                elements.collectionTitle.textContent = title.toUpperCase();
                elements.collectionTitle.classList.add('visible');
            } else {
                elements.collectionTitle.classList.remove('visible');
            }
        }

        // Download Functions
        async function downloadSingleNFT(url, name, index) {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error('Download failed');
                
                const blob = await response.blob();
                const extension = url.includes('.mp4') ? 'mp4' : 'png';
                const fileName = `${sanitizeFileName(name, index)}.${extension}`;
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = fileName;
                link.click();
                
                URL.revokeObjectURL(link.href);
            } catch (error) {
                showError(`Failed to download ${name}`);
            }
        }

        async function downloadAllAssets() {
            if (!state.filteredNFTs.length) return;
            
            const zip = new JSZip();
            
            showModal('Creating ZIP File', `Preparing ${state.filteredNFTs.length} assets`);
            
            state.isDownloadCancelled = false;
            elements.cancelBtn.onclick = () => {
                state.isDownloadCancelled = true;
                updateProgress(0, 'Download cancelled.');
                setTimeout(() => {
                    hideModal();
                }, 1000);
            };
            
            let processed = 0;
            for (const [index, nft] of state.filteredNFTs.entries()) {
                if (state.isDownloadCancelled) {
                    console.log('Download process aborted');
                    return;
                }
                
                try {
                    const response = await fetchWithRetry(nft.cover?.url || '', 3, 2000);
                    if (response && response.ok) {
                        const contentType = response.headers.get('content-type');
                        let extension = 'png';
                        if (contentType?.includes('video/mp4')) {
                            extension = 'mp4';
                        } else if (contentType?.includes('image/jpeg')) {
                            extension = 'jpg';
                        } else if (contentType?.includes('image/gif')) {
                            extension = 'gif';
                        }
                        
                        const blob = await response.blob();
                        if (blob && blob.size > 0) {
                            const sanitizedName = sanitizeFileName(nft.name, index);
                            const fileName = `${sanitizedName}.${extension}`;
                            zip.file(fileName, blob);
                            processed++;
                        }
                    }
                } catch (error) {
                    console.error(`Error downloading NFT ${nft.name}:`, error);
                }
                
                const progress = (processed / state.filteredNFTs.length) * 90;
                updateProgress(progress, `Downloading: ${processed}/${state.filteredNFTs.length}`);
            }
            
            if (state.isDownloadCancelled) {
                console.log('Download process aborted');
                return;
            }

            if (processed === 0) {
                hideModal();
                showError('No assets could be downloaded');
                return;
            }

            updateProgress(95, 'Generating ZIP file');
            try {
                const content = await zip.generateAsync({ type: 'blob' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(content);
                link.download = `${state.currentProfile.username}_nfts.zip`;
                link.click();
                URL.revokeObjectURL(link.href);
                
                updateProgress(100, 'Download complete!');
                setTimeout(hideModal, 1000);
            } catch (error) {
                console.error(`Error generating ZIP: ${error.message}`);
                hideModal();
                showError('Failed to generate ZIP file');
            }
        }

        async function fetchWithRetry(url, retries = 3, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return response;
                } catch (error) {
                    if (i === retries - 1) {
                        throw error;
                    }
                    console.warn(`Retry ${i + 1} for ${url}: ${error.message}`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        async function createCollage() {
            // Silently ignore if a download is already in progress
            if (window.isDownloading) {
                console.log('Download already in progress, ignoring new attempt.');
                return;
            }

            window.isDownloading = true;

            // Collect valid assets from the filtered NFTs
            const validCards = state.filteredNFTs
                .map((nft, index) => ({
                    src: nft.cover?.url || '',
                    title: nft.name || `NFT ${index + 1}`,
                    index,
                    isVideo: nft.cover?.url?.endsWith('.mp4') || false
                }))
                .filter(card => card.src && card.src !== 'https://via.placeholder.com/150' && !card.isVideo);

            if (validCards.length === 0) {
                showError('No valid image assets to include in the collage.');
                window.isDownloading = false;
                return;
            }

            console.log(`Valid cards for collage: ${validCards.length}`, validCards.map(card => ({
                title: card.title,
                index: card.index,
                src: card.src
            })));

            showModal('Creating Collage', `Fetching ${validCards.length} assets`);

            window.isDownloadCancelled = false;
            let collageContainer = null;
            const objectUrls = [];

            elements.cancelBtn.onclick = () => {
                window.isDownloadCancelled = true;
                updateProgress(0, 'Collage creation cancelled.');
                if (collageContainer && document.body.contains(collageContainer)) {
                    document.body.removeChild(collageContainer);
                }
                objectUrls.forEach(url => URL.revokeObjectURL(url));
                setTimeout(() => {
                    hideModal();
                    window.isDownloading = false;
                }, 1000);
            };

            // Fetch images as blobs
            const loadedCards = [];
            const failedImages = [];
            let processed = 0;

            for (const card of validCards) {
                if (window.isDownloadCancelled) {
                    objectUrls.forEach(url => URL.revokeObjectURL(url));
                    window.isDownloading = false;
                    return;
                }

                try {
                    const response = await fetchWithRetry(card.src, 3, 2000);
                    if (response && response.ok) {
                        const blob = await response.blob();
                        if (blob && blob.size > 0) {
                            const objectUrl = URL.createObjectURL(blob);
                            objectUrls.push(objectUrl);
                            loadedCards.push({ ...card, src: objectUrl });
                        } else {
                            failedImages.push(card.title);
                        }
                    } else {
                        failedImages.push(card.title);
                    }
                } catch (error) {
                    console.error(`Error loading image ${card.title}:`, error);
                    failedImages.push(card.title);
                }

                processed++;
                updateProgress((processed / validCards.length) * 70, `Loading images: ${processed}/${validCards.length}`);
            }

            if (window.isDownloadCancelled) {
                objectUrls.forEach(url => URL.revokeObjectURL(url));
                window.isDownloading = false;
                return;
            }

            if (loadedCards.length === 0) {
                showError('No images could be loaded for the collage.');
                objectUrls.forEach(url => URL.revokeObjectURL(url));
                hideModal();
                window.isDownloading = false;
                return;
            }

            if (failedImages.length > 0) {
                console.warn(`Failed to load ${failedImages.length} images:`, failedImages);
            }

            updateProgress(75, `Creating collage with ${loadedCards.length} assets`);

            try {
                // Create temporary container for collage
                collageContainer = document.createElement('div');
                const imageCount = loadedCards.length;
                const cols = Math.ceil(Math.sqrt(imageCount));
                const rows = Math.ceil(imageCount / cols);
                const cardSize = Math.min(200, Math.floor(1200 / cols));

                collageContainer.style.cssText = `
                    position: absolute;
                    top: -9999px;
                    left: -9999px;
                    display: grid;
                    grid-template-columns: repeat(${cols}, ${cardSize}px);
                    grid-template-rows: repeat(${rows}, ${cardSize}px);
                    gap: 4px;
                    background: ${getComputedStyle(document.documentElement).getPropertyValue('--bg-primary')};
                    padding: 20px;
                    width: ${cols * cardSize + (cols - 1) * 4 + 40}px;
                    height: ${rows * cardSize + (rows - 1) * 4 + 40}px;
                `;
                document.body.appendChild(collageContainer);

                // Add images to container
                loadedCards.forEach((card, index) => {
                    const img = document.createElement('img');
                    img.src = card.src;
                    img.style.cssText = `
                        width: ${cardSize}px;
                        height: ${cardSize}px;
                        object-fit: cover;
                        border-radius: 8px;
                    `;
                    collageContainer.appendChild(img);
                });

                // Wait for images to load
                await new Promise(resolve => setTimeout(resolve, 1000));
                updateProgress(90, 'Rendering collage...');

                // Generate canvas and download
                const canvas = await html2canvas(collageContainer, {
                    backgroundColor: getComputedStyle(document.documentElement).getPropertyValue('--bg-primary'),
                    scale: 1,
                    logging: false,
                    useCORS: true
                });

                document.body.removeChild(collageContainer);

                canvas.toBlob((blob) => {
                    if (blob) {
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;

                        // Generate file name parts
                        const cleanUsername = state.currentProfile?.username ? state.currentProfile.username.replace(/[^a-zA-Z0-9-_]/g, '').toUpperCase() : '';
                        const creatorFilter = elements.creatorFilter;
                        const cleanCreator = (creatorFilter?.value || 'UNKNOWN').replace(/[^a-zA-Z0-9-_]/g, '').toUpperCase();
                        const cleanCollectionText = (elements.collectionFilter.value || 'ALL_COLLECTIONS').replace(/[^a-zA-Z0-9-_]/g, '').toUpperCase();

                        // Build filename omitting cleanUsername if empty
                        const fileNameParts = [];
                        if (cleanUsername) fileNameParts.push(cleanUsername);
                        if (cleanCreator !== 'UNKNOWN') fileNameParts.push(cleanCreator);
                        fileNameParts.push(cleanCollectionText);
                        a.download = fileNameParts.join('_') + '.png';

                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);

                        updateProgress(100, 'Collage download complete!');
                        setTimeout(() => {
                            hideModal();
                            window.isDownloading = false;
                        }, 1500);
                    } else {
                        throw new Error('Failed to create blob from canvas');
                    }

                    // Clean up object URLs
                    objectUrls.forEach(url => URL.revokeObjectURL(url));
                },
                'image/png',
                1.0
                );
            } catch (error) {
                console.error('Error creating collage:', error);
                showError(`Failed to create collage: ${error.message}`);
                if (collageContainer && document.body.contains(collageContainer)) {
                    document.body.removeChild(collageContainer);
                }
                objectUrls.forEach(url => URL.revokeObjectURL(url));
                hideModal();
                window.isDownloading = false;
            }
        }

        function openNFTPage(nftId) {
            window.open(`https://crypto.com/nft/asset/${nftId}`, '_blank');
        }

        // Theme Functions
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'modern';
            const newTheme = currentTheme === 'modern' ? 'light' : 'modern';
            
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            elements.themeIcon.textContent = newTheme === 'modern' ? 'üåô' : '‚òÄÔ∏è';
        }

        // Scroll Functions
        function updateScrollButton() {
            const scrolled = window.scrollY > 500;
            elements.scrollTop.classList.toggle('visible', scrolled);
        }

        function scrollToTop() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // Event Listeners
        function initializeEventListeners() {
            // Search
            elements.searchInput.addEventListener('input', debounce((e) => {
                searchProfiles(sanitizeInput(e.target.value));
            }, 300));
            
            // Hide suggestions when clicking outside
            document.addEventListener('click', (e) => {
                if (!elements.searchInput.contains(e.target) && !elements.suggestions.contains(e.target)) {
                    elements.suggestions.style.display = 'none';
                }
            });
            
            // Theme toggle
            elements.themeToggle.addEventListener('click', toggleTheme);
            
            // Filters
            elements.creatorFilter.addEventListener('change', filterNFTs);
            elements.collectionFilter.addEventListener('change', filterNFTs);
            elements.chainFilter.addEventListener('change', filterNFTs);
            elements.statusFilter.addEventListener('change', filterNFTs);
            elements.sortFilter.addEventListener('change', filterNFTs);
            
            // Grid size
            elements.gridSizeFilter.addEventListener('change', () => {
                const size = elements.gridSizeFilter.value;
                elements.nftGrid.className = `nft-grid ${size}`;
            });
            
            // Download buttons
            elements.downloadAssetsBtn.addEventListener('click', downloadAllAssets);
            elements.downloadCollageBtn.addEventListener('click', createCollage);
            
            // Scroll
            window.addEventListener('scroll', updateScrollButton);
            elements.scrollTop.addEventListener('click', scrollToTop);
            
            // Close modal on outside click
            elements.progressModal.addEventListener('click', (e) => {
                if (e.target === elements.progressModal) {
                    hideModal();
                }
            });
        }

        // Initialize Application
        function initializeApp() {
            // Load saved theme
            const savedTheme = localStorage.getItem('theme') || 'modern';
            document.documentElement.setAttribute('data-theme', savedTheme);
            elements.themeIcon.textContent = savedTheme === 'modern' ? 'üåô' : '‚òÄÔ∏è';
            
            // Initialize event listeners
            initializeEventListeners();
            
            // Initial scroll button state
            updateScrollButton();
            
            console.log('NFT Explorer Pro initialized');
        }

        // Start the application
        document.addEventListener('DOMContentLoaded', initializeApp);

        // Global functions for inline event handlers
        window.downloadSingleNFT = downloadSingleNFT;
        window.openNFTPage = openNFTPage;
    </script>
</body>
</html>
